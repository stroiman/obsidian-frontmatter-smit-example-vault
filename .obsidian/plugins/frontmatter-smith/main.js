/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/function.js
var require_function = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/function.js"(exports) {
    "use strict";
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dual = exports.getEndomorphismMonoid = exports.SK = exports.hole = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.unsafeCoerce = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
    exports.identity = identity2;
    exports.constant = constant;
    exports.flip = flip;
    exports.flow = flow2;
    exports.tuple = tuple;
    exports.increment = increment;
    exports.decrement = decrement;
    exports.absurd = absurd;
    exports.tupled = tupled;
    exports.untupled = untupled;
    exports.pipe = pipe4;
    exports.not = not;
    var getBooleanAlgebra = function(B) {
      return function() {
        return {
          meet: function(x, y) {
            return function(a) {
              return B.meet(x(a), y(a));
            };
          },
          join: function(x, y) {
            return function(a) {
              return B.join(x(a), y(a));
            };
          },
          zero: function() {
            return B.zero;
          },
          one: function() {
            return B.one;
          },
          implies: function(x, y) {
            return function(a) {
              return B.implies(x(a), y(a));
            };
          },
          not: function(x) {
            return function(a) {
              return B.not(x(a));
            };
          }
        };
      };
    };
    exports.getBooleanAlgebra = getBooleanAlgebra;
    var getSemigroup = function(S) {
      return function() {
        return {
          concat: function(f, g) {
            return function(a) {
              return S.concat(f(a), g(a));
            };
          }
        };
      };
    };
    exports.getSemigroup = getSemigroup;
    var getMonoid = function(M) {
      var getSemigroupM = (0, exports.getSemigroup)(M);
      return function() {
        return {
          concat: getSemigroupM().concat,
          empty: function() {
            return M.empty;
          }
        };
      };
    };
    exports.getMonoid = getMonoid;
    var getSemiring = function(S) {
      return {
        add: function(f, g) {
          return function(x) {
            return S.add(f(x), g(x));
          };
        },
        zero: function() {
          return S.zero;
        },
        mul: function(f, g) {
          return function(x) {
            return S.mul(f(x), g(x));
          };
        },
        one: function() {
          return S.one;
        }
      };
    };
    exports.getSemiring = getSemiring;
    var getRing = function(R) {
      var S = (0, exports.getSemiring)(R);
      return {
        add: S.add,
        mul: S.mul,
        one: S.one,
        zero: S.zero,
        sub: function(f, g) {
          return function(x) {
            return R.sub(f(x), g(x));
          };
        }
      };
    };
    exports.getRing = getRing;
    var apply = function(a) {
      return function(f) {
        return f(a);
      };
    };
    exports.apply = apply;
    function identity2(a) {
      return a;
    }
    exports.unsafeCoerce = identity2;
    function constant(a) {
      return function() {
        return a;
      };
    }
    exports.constTrue = constant(true);
    exports.constFalse = constant(false);
    exports.constNull = constant(null);
    exports.constUndefined = constant(void 0);
    exports.constVoid = exports.constUndefined;
    function flip(f) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (args.length > 1) {
          return f(args[1], args[0]);
        }
        return function(a) {
          return f(a)(args[0]);
        };
      };
    }
    function flow2(ab, bc, cd, de, ef, fg, gh, hi, ij) {
      switch (arguments.length) {
        case 1:
          return ab;
        case 2:
          return function() {
            return bc(ab.apply(this, arguments));
          };
        case 3:
          return function() {
            return cd(bc(ab.apply(this, arguments)));
          };
        case 4:
          return function() {
            return de(cd(bc(ab.apply(this, arguments))));
          };
        case 5:
          return function() {
            return ef(de(cd(bc(ab.apply(this, arguments)))));
          };
        case 6:
          return function() {
            return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
          };
        case 7:
          return function() {
            return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
          };
        case 8:
          return function() {
            return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
          };
        case 9:
          return function() {
            return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
          };
      }
      return;
    }
    function tuple() {
      var t5 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        t5[_i] = arguments[_i];
      }
      return t5;
    }
    function increment(n) {
      return n + 1;
    }
    function decrement(n) {
      return n - 1;
    }
    function absurd(_) {
      throw new Error("Called `absurd` function which should be uncallable");
    }
    function tupled(f) {
      return function(a) {
        return f.apply(void 0, a);
      };
    }
    function untupled(f) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return f(a);
      };
    }
    function pipe4(a, ab, bc, cd, de, ef, fg, gh, hi) {
      switch (arguments.length) {
        case 1:
          return a;
        case 2:
          return ab(a);
        case 3:
          return bc(ab(a));
        case 4:
          return cd(bc(ab(a)));
        case 5:
          return de(cd(bc(ab(a))));
        case 6:
          return ef(de(cd(bc(ab(a)))));
        case 7:
          return fg(ef(de(cd(bc(ab(a))))));
        case 8:
          return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
          return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        default: {
          var ret = arguments[0];
          for (var i = 1; i < arguments.length; i++) {
            ret = arguments[i](ret);
          }
          return ret;
        }
      }
    }
    exports.hole = absurd;
    var SK = function(_, b) {
      return b;
    };
    exports.SK = SK;
    function not(predicate) {
      return function(a) {
        return !predicate(a);
      };
    }
    var getEndomorphismMonoid = function() {
      return {
        concat: function(first, second) {
          return flow2(first, second);
        },
        empty: identity2
      };
    };
    exports.getEndomorphismMonoid = getEndomorphismMonoid;
    var dual2 = function(arity, body) {
      var isDataFirst = typeof arity === "number" ? function(args) {
        return args.length >= arity;
      } : arity;
      return function() {
        var args = Array.from(arguments);
        if (isDataFirst(arguments)) {
          return body.apply(this, args);
        }
        return function(self) {
          return body.apply(void 0, __spreadArray2([self], args, false));
        };
      };
    };
    exports.dual = dual2;
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/internal.js
var require_internal = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/internal.js"(exports) {
    "use strict";
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flatMapReader = exports.flatMapTask = exports.flatMapIO = exports.flatMapEither = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.fromReadonlyNonEmptyArray = exports.has = exports.emptyRecord = exports.emptyReadonlyArray = exports.tail = exports.head = exports.isNonEmpty = exports.singleton = exports.right = exports.left = exports.isRight = exports.isLeft = exports.some = exports.none = exports.isSome = exports.isNone = void 0;
    var function_1 = require_function();
    var isNone = function(fa) {
      return fa._tag === "None";
    };
    exports.isNone = isNone;
    var isSome = function(fa) {
      return fa._tag === "Some";
    };
    exports.isSome = isSome;
    exports.none = { _tag: "None" };
    var some = function(a) {
      return { _tag: "Some", value: a };
    };
    exports.some = some;
    var isLeft3 = function(ma) {
      return ma._tag === "Left";
    };
    exports.isLeft = isLeft3;
    var isRight2 = function(ma) {
      return ma._tag === "Right";
    };
    exports.isRight = isRight2;
    var left2 = function(e) {
      return { _tag: "Left", left: e };
    };
    exports.left = left2;
    var right3 = function(a) {
      return { _tag: "Right", right: a };
    };
    exports.right = right3;
    var singleton = function(a) {
      return [a];
    };
    exports.singleton = singleton;
    var isNonEmpty2 = function(as3) {
      return as3.length > 0;
    };
    exports.isNonEmpty = isNonEmpty2;
    var head2 = function(as3) {
      return as3[0];
    };
    exports.head = head2;
    var tail = function(as3) {
      return as3.slice(1);
    };
    exports.tail = tail;
    exports.emptyReadonlyArray = [];
    exports.emptyRecord = {};
    exports.has = Object.prototype.hasOwnProperty;
    var fromReadonlyNonEmptyArray = function(as3) {
      return __spreadArray2([as3[0]], as3.slice(1), true);
    };
    exports.fromReadonlyNonEmptyArray = fromReadonlyNonEmptyArray;
    var liftNullable2 = function(F) {
      return function(f, onNullable) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          var o = f.apply(void 0, a);
          return F.fromEither(o == null ? (0, exports.left)(onNullable.apply(void 0, a)) : (0, exports.right)(o));
        };
      };
    };
    exports.liftNullable = liftNullable2;
    var liftOption2 = function(F) {
      return function(f, onNone) {
        return function() {
          var a = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
          }
          var o = f.apply(void 0, a);
          return F.fromEither((0, exports.isNone)(o) ? (0, exports.left)(onNone.apply(void 0, a)) : (0, exports.right)(o.value));
        };
      };
    };
    exports.liftOption = liftOption2;
    var flatMapNullable2 = function(F, M) {
      return /* @__PURE__ */ (0, function_1.dual)(3, function(self, f, onNullable) {
        return M.flatMap(self, (0, exports.liftNullable)(F)(f, onNullable));
      });
    };
    exports.flatMapNullable = flatMapNullable2;
    var flatMapOption2 = function(F, M) {
      return /* @__PURE__ */ (0, function_1.dual)(3, function(self, f, onNone) {
        return M.flatMap(self, (0, exports.liftOption)(F)(f, onNone));
      });
    };
    exports.flatMapOption = flatMapOption2;
    var flatMapEither = function(F, M) {
      return /* @__PURE__ */ (0, function_1.dual)(2, function(self, f) {
        return M.flatMap(self, function(a) {
          return F.fromEither(f(a));
        });
      });
    };
    exports.flatMapEither = flatMapEither;
    var flatMapIO = function(F, M) {
      return /* @__PURE__ */ (0, function_1.dual)(2, function(self, f) {
        return M.flatMap(self, function(a) {
          return F.fromIO(f(a));
        });
      });
    };
    exports.flatMapIO = flatMapIO;
    var flatMapTask = function(F, M) {
      return /* @__PURE__ */ (0, function_1.dual)(2, function(self, f) {
        return M.flatMap(self, function(a) {
          return F.fromTask(f(a));
        });
      });
    };
    exports.flatMapTask = flatMapTask;
    var flatMapReader = function(F, M) {
      return /* @__PURE__ */ (0, function_1.dual)(2, function(self, f) {
        return M.flatMap(self, function(a) {
          return F.fromReader(f(a));
        });
      });
    };
    exports.flatMapReader = flatMapReader;
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Apply.js
var require_Apply = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Apply.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ap = ap2;
    exports.apFirst = apFirst;
    exports.apSecond = apSecond;
    exports.apS = apS;
    exports.getApplySemigroup = getApplySemigroup;
    exports.sequenceT = sequenceT;
    exports.sequenceS = sequenceS;
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function ap2(F, G) {
      return function(fa) {
        return function(fab) {
          return F.ap(F.map(fab, function(gab) {
            return function(ga) {
              return G.ap(gab, ga);
            };
          }), fa);
        };
      };
    }
    function apFirst(A) {
      return function(second) {
        return function(first) {
          return A.ap(A.map(first, function(a) {
            return function() {
              return a;
            };
          }), second);
        };
      };
    }
    function apSecond(A) {
      return function(second) {
        return function(first) {
          return A.ap(A.map(first, function() {
            return function(b) {
              return b;
            };
          }), second);
        };
      };
    }
    function apS(F) {
      return function(name, fb) {
        return function(fa) {
          return F.ap(F.map(fa, function(a) {
            return function(b) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            };
          }), fb);
        };
      };
    }
    function getApplySemigroup(F) {
      return function(S) {
        return {
          concat: function(first, second) {
            return F.ap(F.map(first, function(x) {
              return function(y) {
                return S.concat(x, y);
              };
            }), second);
          }
        };
      };
    }
    function curried(f, n, acc) {
      return function(x) {
        var combined = Array(acc.length + 1);
        for (var i = 0; i < acc.length; i++) {
          combined[i] = acc[i];
        }
        combined[acc.length] = x;
        return n === 0 ? f.apply(null, combined) : curried(f, n - 1, combined);
      };
    }
    var tupleConstructors = {
      1: function(a) {
        return [a];
      },
      2: function(a) {
        return function(b) {
          return [a, b];
        };
      },
      3: function(a) {
        return function(b) {
          return function(c) {
            return [a, b, c];
          };
        };
      },
      4: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return [a, b, c, d];
            };
          };
        };
      },
      5: function(a) {
        return function(b) {
          return function(c) {
            return function(d) {
              return function(e) {
                return [a, b, c, d, e];
              };
            };
          };
        };
      }
    };
    function getTupleConstructor(len) {
      if (!_.has.call(tupleConstructors, len)) {
        tupleConstructors[len] = curried(function_1.tuple, len - 1, []);
      }
      return tupleConstructors[len];
    }
    function sequenceT(F) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var len = args.length;
        var f = getTupleConstructor(len);
        var fas = F.map(args[0], f);
        for (var i = 1; i < len; i++) {
          fas = F.ap(fas, args[i]);
        }
        return fas;
      };
    }
    function getRecordConstructor(keys) {
      var len = keys.length;
      switch (len) {
        case 1:
          return function(a) {
            var _a;
            return _a = {}, _a[keys[0]] = a, _a;
          };
        case 2:
          return function(a) {
            return function(b) {
              var _a;
              return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a;
            };
          };
        case 3:
          return function(a) {
            return function(b) {
              return function(c) {
                var _a;
                return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a;
              };
            };
          };
        case 4:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  var _a;
                  return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a[keys[3]] = d, _a;
                };
              };
            };
          };
        case 5:
          return function(a) {
            return function(b) {
              return function(c) {
                return function(d) {
                  return function(e) {
                    var _a;
                    return _a = {}, _a[keys[0]] = a, _a[keys[1]] = b, _a[keys[2]] = c, _a[keys[3]] = d, _a[keys[4]] = e, _a;
                  };
                };
              };
            };
          };
        default:
          return curried(function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var r = {};
            for (var i = 0; i < len; i++) {
              r[keys[i]] = args[i];
            }
            return r;
          }, len - 1, []);
      }
    }
    function sequenceS(F) {
      return function(r) {
        var keys = Object.keys(r);
        var len = keys.length;
        var f = getRecordConstructor(keys);
        var fr = F.map(r[keys[0]], f);
        for (var i = 1; i < len; i++) {
          fr = F.ap(fr, r[keys[i]]);
        }
        return fr;
      };
    }
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Functor.js
var require_Functor = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Functor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.map = map3;
    exports.flap = flap2;
    exports.bindTo = bindTo2;
    exports.let = let_2;
    exports.getFunctorComposition = getFunctorComposition;
    exports.as = as3;
    exports.asUnit = asUnit3;
    var function_1 = require_function();
    function map3(F, G) {
      return function(f) {
        return function(fa) {
          return F.map(fa, function(ga) {
            return G.map(ga, f);
          });
        };
      };
    }
    function flap2(F) {
      return function(a) {
        return function(fab) {
          return F.map(fab, function(f) {
            return f(a);
          });
        };
      };
    }
    function bindTo2(F) {
      return function(name) {
        return function(fa) {
          return F.map(fa, function(a) {
            var _a;
            return _a = {}, _a[name] = a, _a;
          });
        };
      };
    }
    function let_2(F) {
      return function(name, f) {
        return function(fa) {
          return F.map(fa, function(a) {
            var _a;
            return Object.assign({}, a, (_a = {}, _a[name] = f(a), _a));
          });
        };
      };
    }
    function getFunctorComposition(F, G) {
      var _map2 = map3(F, G);
      return {
        map: function(fga, f) {
          return (0, function_1.pipe)(fga, _map2(f));
        }
      };
    }
    function as3(F) {
      return function(self, b) {
        return F.map(self, function() {
          return b;
        });
      };
    }
    function asUnit3(F) {
      var asM = as3(F);
      return function(self) {
        return asM(self, void 0);
      };
    }
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Applicative.js
var require_Applicative = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Applicative.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getApplicativeMonoid = getApplicativeMonoid;
    exports.getApplicativeComposition = getApplicativeComposition;
    var Apply_1 = require_Apply();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    function getApplicativeMonoid(F) {
      var f = (0, Apply_1.getApplySemigroup)(F);
      return function(M) {
        return {
          concat: f(M).concat,
          empty: F.of(M.empty)
        };
      };
    }
    function getApplicativeComposition(F, G) {
      var map3 = (0, Functor_1.getFunctorComposition)(F, G).map;
      var _ap2 = (0, Apply_1.ap)(F, G);
      return {
        map: map3,
        of: function(a) {
          return F.of(G.of(a));
        },
        ap: function(fgab, fga) {
          return (0, function_1.pipe)(fgab, _ap2(fga));
        }
      };
    }
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Chain.js
var require_Chain = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Chain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.chainFirst = chainFirst;
    exports.tap = tap3;
    exports.bind = bind3;
    function chainFirst(M) {
      var tapM = tap3(M);
      return function(f) {
        return function(first) {
          return tapM(first, f);
        };
      };
    }
    function tap3(M) {
      return function(first, f) {
        return M.chain(first, function(a) {
          return M.map(f(a), function() {
            return a;
          });
        });
      };
    }
    function bind3(M) {
      return function(name, f) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return M.map(f(a), function(b) {
              var _a;
              return Object.assign({}, a, (_a = {}, _a[name] = b, _a));
            });
          });
        };
      };
    }
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/ChainRec.js
var require_ChainRec = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/ChainRec.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tailRec = void 0;
    var tailRec = function(startWith, f) {
      var ab = f(startWith);
      while (ab._tag === "Left") {
        ab = f(ab.left);
      }
      return ab.right;
    };
    exports.tailRec = tailRec;
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/FromEither.js
var require_FromEither = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/FromEither.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromOption = fromOption;
    exports.fromPredicate = fromPredicate;
    exports.fromOptionK = fromOptionK;
    exports.chainOptionK = chainOptionK;
    exports.fromEitherK = fromEitherK;
    exports.chainEitherK = chainEitherK;
    exports.chainFirstEitherK = chainFirstEitherK;
    exports.filterOrElse = filterOrElse;
    exports.tapEither = tapEither;
    var Chain_1 = require_Chain();
    var function_1 = require_function();
    var _ = __importStar(require_internal());
    function fromOption(F) {
      return function(onNone) {
        return function(ma) {
          return F.fromEither(_.isNone(ma) ? _.left(onNone()) : _.right(ma.value));
        };
      };
    }
    function fromPredicate(F) {
      return function(predicate, onFalse) {
        return function(a) {
          return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
        };
      };
    }
    function fromOptionK(F) {
      var fromOptionF = fromOption(F);
      return function(onNone) {
        var from = fromOptionF(onNone);
        return function(f) {
          return (0, function_1.flow)(f, from);
        };
      };
    }
    function chainOptionK(F, M) {
      var fromOptionKF = fromOptionK(F);
      return function(onNone) {
        var from = fromOptionKF(onNone);
        return function(f) {
          return function(ma) {
            return M.chain(ma, from(f));
          };
        };
      };
    }
    function fromEitherK(F) {
      return function(f) {
        return (0, function_1.flow)(f, F.fromEither);
      };
    }
    function chainEitherK(F, M) {
      var fromEitherKF = fromEitherK(F);
      return function(f) {
        return function(ma) {
          return M.chain(ma, fromEitherKF(f));
        };
      };
    }
    function chainFirstEitherK(F, M) {
      var tapEitherM = tapEither(F, M);
      return function(f) {
        return function(ma) {
          return tapEitherM(ma, f);
        };
      };
    }
    function filterOrElse(F, M) {
      return function(predicate, onFalse) {
        return function(ma) {
          return M.chain(ma, function(a) {
            return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a)));
          });
        };
      };
    }
    function tapEither(F, M) {
      var fromEither = fromEitherK(F);
      var tapM = (0, Chain_1.tap)(M);
      return function(self, f) {
        return tapM(self, fromEither(f));
      };
    }
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Separated.js
var require_Separated = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Separated.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.right = exports.left = exports.flap = exports.Functor = exports.Bifunctor = exports.URI = exports.bimap = exports.mapLeft = exports.map = exports.separated = void 0;
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var separated = function(left3, right4) {
      return { left: left3, right: right4 };
    };
    exports.separated = separated;
    var _map2 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f));
    };
    var _mapLeft = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
    };
    var _bimap = function(fa, g, f) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(g, f));
    };
    var map3 = function(f) {
      return function(fa) {
        return (0, exports.separated)((0, exports.left)(fa), f((0, exports.right)(fa)));
      };
    };
    exports.map = map3;
    var mapLeft = function(f) {
      return function(fa) {
        return (0, exports.separated)(f((0, exports.left)(fa)), (0, exports.right)(fa));
      };
    };
    exports.mapLeft = mapLeft;
    var bimap = function(f, g) {
      return function(fa) {
        return (0, exports.separated)(f((0, exports.left)(fa)), g((0, exports.right)(fa)));
      };
    };
    exports.bimap = bimap;
    exports.URI = "Separated";
    exports.Bifunctor = {
      URI: exports.URI,
      mapLeft: _mapLeft,
      bimap: _bimap
    };
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    var left2 = function(s) {
      return s.left;
    };
    exports.left = left2;
    var right3 = function(s) {
      return s.right;
    };
    exports.right = right3;
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Witherable.js
var require_Witherable = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Witherable.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wiltDefault = wiltDefault;
    exports.witherDefault = witherDefault;
    exports.filterE = filterE;
    var _ = __importStar(require_internal());
    function wiltDefault(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f) {
          return F.map(traverseF(wa, f), C.separate);
        };
      };
    }
    function witherDefault(T, C) {
      return function(F) {
        var traverseF = T.traverse(F);
        return function(wa, f) {
          return F.map(traverseF(wa, f), C.compact);
        };
      };
    }
    function filterE(W) {
      return function(F) {
        var witherF = W.wither(F);
        return function(predicate) {
          return function(ga) {
            return witherF(ga, function(a) {
              return F.map(predicate(a), function(b) {
                return b ? _.some(a) : _.none;
              });
            });
          };
        };
      };
    }
  }
});

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Either.js
var require_Either = __commonJS({
  "node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/lib/Either.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.asUnit = exports.as = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.flatMap = exports.right = exports.left = void 0;
    exports.either = exports.stringifyJSON = exports.chainFirstW = exports.chainFirst = exports.chain = exports.chainW = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.let = exports.bindTo = exports.Do = exports.exists = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.flatMapOption = exports.flatMapNullable = exports.liftOption = exports.liftNullable = exports.chainOptionKW = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.tap = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = void 0;
    exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = void 0;
    exports.toError = toError;
    exports.elem = elem;
    exports.parseJSON = parseJSON;
    exports.getValidation = getValidation;
    var Applicative_1 = require_Applicative();
    var Apply_1 = require_Apply();
    var chainable = __importStar(require_Chain());
    var ChainRec_1 = require_ChainRec();
    var FromEither_1 = require_FromEither();
    var function_1 = require_function();
    var Functor_1 = require_Functor();
    var _ = __importStar(require_internal());
    var Separated_1 = require_Separated();
    var Witherable_1 = require_Witherable();
    exports.left = _.left;
    exports.right = _.right;
    exports.flatMap = (0, function_1.dual)(2, function(ma, f) {
      return (0, exports.isLeft)(ma) ? ma : f(ma.right);
    });
    var _map2 = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.map)(f));
    };
    var _ap2 = function(fab, fa) {
      return (0, function_1.pipe)(fab, (0, exports.ap)(fa));
    };
    var _reduce = function(fa, b, f) {
      return (0, function_1.pipe)(fa, (0, exports.reduce)(b, f));
    };
    var _foldMap = function(M) {
      return function(fa, f) {
        var foldMapM = (0, exports.foldMap)(M);
        return (0, function_1.pipe)(fa, foldMapM(f));
      };
    };
    var _reduceRight = function(fa, b, f) {
      return (0, function_1.pipe)(fa, (0, exports.reduceRight)(b, f));
    };
    var _traverse = function(F) {
      var traverseF = (0, exports.traverse)(F);
      return function(ta, f) {
        return (0, function_1.pipe)(ta, traverseF(f));
      };
    };
    var _bimap = function(fa, f, g) {
      return (0, function_1.pipe)(fa, (0, exports.bimap)(f, g));
    };
    var _mapLeft = function(fa, f) {
      return (0, function_1.pipe)(fa, (0, exports.mapLeft)(f));
    };
    var _alt = function(fa, that) {
      return (0, function_1.pipe)(fa, (0, exports.alt)(that));
    };
    var _extend = function(wa, f) {
      return (0, function_1.pipe)(wa, (0, exports.extend)(f));
    };
    var _chainRec = function(a, f) {
      return (0, ChainRec_1.tailRec)(f(a), function(e) {
        return (0, exports.isLeft)(e) ? (0, exports.right)((0, exports.left)(e.left)) : (0, exports.isLeft)(e.right) ? (0, exports.left)(f(e.right.left)) : (0, exports.right)((0, exports.right)(e.right.right));
      });
    };
    exports.URI = "Either";
    var getShow = function(SE, SA) {
      return {
        show: function(ma) {
          return (0, exports.isLeft)(ma) ? "left(".concat(SE.show(ma.left), ")") : "right(".concat(SA.show(ma.right), ")");
        }
      };
    };
    exports.getShow = getShow;
    var getEq = function(EL, EA) {
      return {
        equals: function(x, y) {
          return x === y || ((0, exports.isLeft)(x) ? (0, exports.isLeft)(y) && EL.equals(x.left, y.left) : (0, exports.isRight)(y) && EA.equals(x.right, y.right));
        }
      };
    };
    exports.getEq = getEq;
    var getSemigroup = function(S) {
      return {
        concat: function(x, y) {
          return (0, exports.isLeft)(y) ? x : (0, exports.isLeft)(x) ? y : (0, exports.right)(S.concat(x.right, y.right));
        }
      };
    };
    exports.getSemigroup = getSemigroup;
    var getCompactable = function(M) {
      var empty = (0, exports.left)(M.empty);
      return {
        URI: exports.URI,
        _E: void 0,
        compact: function(ma) {
          return (0, exports.isLeft)(ma) ? ma : ma.right._tag === "None" ? empty : (0, exports.right)(ma.right.value);
        },
        separate: function(ma) {
          return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : (0, exports.isLeft)(ma.right) ? (0, Separated_1.separated)((0, exports.right)(ma.right.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(ma.right.right));
        }
      };
    };
    exports.getCompactable = getCompactable;
    var getFilterable = function(M) {
      var empty = (0, exports.left)(M.empty);
      var _a = (0, exports.getCompactable)(M), compact = _a.compact, separate = _a.separate;
      var filter = function(ma, predicate) {
        return (0, exports.isLeft)(ma) ? ma : predicate(ma.right) ? ma : empty;
      };
      var partition = function(ma, p3) {
        return (0, exports.isLeft)(ma) ? (0, Separated_1.separated)(ma, ma) : p3(ma.right) ? (0, Separated_1.separated)(empty, (0, exports.right)(ma.right)) : (0, Separated_1.separated)((0, exports.right)(ma.right), empty);
      };
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact,
        separate,
        filter,
        filterMap: function(ma, f) {
          if ((0, exports.isLeft)(ma)) {
            return ma;
          }
          var ob = f(ma.right);
          return ob._tag === "None" ? empty : (0, exports.right)(ob.value);
        },
        partition,
        partitionMap: function(ma, f) {
          if ((0, exports.isLeft)(ma)) {
            return (0, Separated_1.separated)(ma, ma);
          }
          var e = f(ma.right);
          return (0, exports.isLeft)(e) ? (0, Separated_1.separated)((0, exports.right)(e.left), empty) : (0, Separated_1.separated)(empty, (0, exports.right)(e.right));
        }
      };
    };
    exports.getFilterable = getFilterable;
    var getWitherable = function(M) {
      var F_ = (0, exports.getFilterable)(M);
      var C = (0, exports.getCompactable)(M);
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        compact: F_.compact,
        separate: F_.separate,
        filter: F_.filter,
        filterMap: F_.filterMap,
        partition: F_.partition,
        partitionMap: F_.partitionMap,
        traverse: _traverse,
        sequence: exports.sequence,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        wither: (0, Witherable_1.witherDefault)(exports.Traversable, C),
        wilt: (0, Witherable_1.wiltDefault)(exports.Traversable, C)
      };
    };
    exports.getWitherable = getWitherable;
    var getApplicativeValidation = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        ap: function(fab, fa) {
          return (0, exports.isLeft)(fab) ? (0, exports.isLeft)(fa) ? (0, exports.left)(SE.concat(fab.left, fa.left)) : fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
        },
        of: exports.of
      };
    };
    exports.getApplicativeValidation = getApplicativeValidation;
    var getAltValidation = function(SE) {
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        alt: function(me, that) {
          if ((0, exports.isRight)(me)) {
            return me;
          }
          var ea = that();
          return (0, exports.isLeft)(ea) ? (0, exports.left)(SE.concat(me.left, ea.left)) : ea;
        }
      };
    };
    exports.getAltValidation = getAltValidation;
    var map3 = function(f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? fa : (0, exports.right)(f(fa.right));
      };
    };
    exports.map = map3;
    exports.Functor = {
      URI: exports.URI,
      map: _map2
    };
    exports.as = (0, function_1.dual)(2, (0, Functor_1.as)(exports.Functor));
    exports.asUnit = (0, Functor_1.asUnit)(exports.Functor);
    exports.of = exports.right;
    exports.Pointed = {
      URI: exports.URI,
      of: exports.of
    };
    var apW2 = function(fa) {
      return function(fab) {
        return (0, exports.isLeft)(fab) ? fab : (0, exports.isLeft)(fa) ? fa : (0, exports.right)(fab.right(fa.right));
      };
    };
    exports.apW = apW2;
    exports.ap = exports.apW;
    exports.Apply = {
      URI: exports.URI,
      map: _map2,
      ap: _ap2
    };
    exports.Applicative = {
      URI: exports.URI,
      map: _map2,
      ap: _ap2,
      of: exports.of
    };
    exports.Chain = {
      URI: exports.URI,
      map: _map2,
      ap: _ap2,
      chain: exports.flatMap
    };
    exports.Monad = {
      URI: exports.URI,
      map: _map2,
      ap: _ap2,
      of: exports.of,
      chain: exports.flatMap
    };
    var reduce = function(b, f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f(b, fa.right);
      };
    };
    exports.reduce = reduce;
    var foldMap = function(M) {
      return function(f) {
        return function(fa) {
          return (0, exports.isLeft)(fa) ? M.empty : f(fa.right);
        };
      };
    };
    exports.foldMap = foldMap;
    var reduceRight = function(b, f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? b : f(fa.right, b);
      };
    };
    exports.reduceRight = reduceRight;
    exports.Foldable = {
      URI: exports.URI,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight
    };
    var traverse = function(F) {
      return function(f) {
        return function(ta) {
          return (0, exports.isLeft)(ta) ? F.of((0, exports.left)(ta.left)) : F.map(f(ta.right), exports.right);
        };
      };
    };
    exports.traverse = traverse;
    var sequence = function(F) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? F.of((0, exports.left)(ma.left)) : F.map(ma.right, exports.right);
      };
    };
    exports.sequence = sequence;
    exports.Traversable = {
      URI: exports.URI,
      map: _map2,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence
    };
    var bimap = function(f, g) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : (0, exports.right)(g(fa.right));
      };
    };
    exports.bimap = bimap;
    var mapLeft = function(f) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? (0, exports.left)(f(fa.left)) : fa;
      };
    };
    exports.mapLeft = mapLeft;
    exports.Bifunctor = {
      URI: exports.URI,
      bimap: _bimap,
      mapLeft: _mapLeft
    };
    var altW = function(that) {
      return function(fa) {
        return (0, exports.isLeft)(fa) ? that() : fa;
      };
    };
    exports.altW = altW;
    exports.alt = exports.altW;
    exports.Alt = {
      URI: exports.URI,
      map: _map2,
      alt: _alt
    };
    var extend = function(f) {
      return function(wa) {
        return (0, exports.isLeft)(wa) ? wa : (0, exports.right)(f(wa));
      };
    };
    exports.extend = extend;
    exports.Extend = {
      URI: exports.URI,
      map: _map2,
      extend: _extend
    };
    exports.ChainRec = {
      URI: exports.URI,
      map: _map2,
      ap: _ap2,
      chain: exports.flatMap,
      chainRec: _chainRec
    };
    exports.throwError = exports.left;
    exports.MonadThrow = {
      URI: exports.URI,
      map: _map2,
      ap: _ap2,
      of: exports.of,
      chain: exports.flatMap,
      throwError: exports.throwError
    };
    exports.FromEither = {
      URI: exports.URI,
      fromEither: function_1.identity
    };
    exports.fromPredicate = (0, FromEither_1.fromPredicate)(exports.FromEither);
    exports.fromOption = /* @__PURE__ */ (0, FromEither_1.fromOption)(exports.FromEither);
    exports.isLeft = _.isLeft;
    exports.isRight = _.isRight;
    var matchW = function(onLeft, onRight) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : onRight(ma.right);
      };
    };
    exports.matchW = matchW;
    exports.foldW = exports.matchW;
    exports.match = exports.matchW;
    exports.fold = exports.match;
    var getOrElseW = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma.right;
      };
    };
    exports.getOrElseW = getOrElseW;
    exports.getOrElse = exports.getOrElseW;
    exports.flap = (0, Functor_1.flap)(exports.Functor);
    exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
    exports.apFirstW = exports.apFirst;
    exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
    exports.apSecondW = exports.apSecond;
    exports.tap = (0, function_1.dual)(2, chainable.tap(exports.Chain));
    exports.flattenW = /* @__PURE__ */ (0, exports.flatMap)(function_1.identity);
    exports.flatten = exports.flattenW;
    exports.duplicate = (0, exports.extend)(function_1.identity);
    exports.fromOptionK = /* @__PURE__ */ (0, FromEither_1.fromOptionK)(exports.FromEither);
    exports.chainOptionK = (0, FromEither_1.chainOptionK)(exports.FromEither, exports.Chain);
    exports.chainOptionKW = exports.chainOptionK;
    var _FromEither2 = {
      fromEither: exports.FromEither.fromEither
    };
    exports.liftNullable = _.liftNullable(_FromEither2);
    exports.liftOption = _.liftOption(_FromEither2);
    var _FlatMap = {
      flatMap: exports.flatMap
    };
    exports.flatMapNullable = _.flatMapNullable(_FromEither2, _FlatMap);
    exports.flatMapOption = _.flatMapOption(_FromEither2, _FlatMap);
    exports.filterOrElse = (0, FromEither_1.filterOrElse)(exports.FromEither, exports.Chain);
    exports.filterOrElseW = exports.filterOrElse;
    var swap = function(ma) {
      return (0, exports.isLeft)(ma) ? (0, exports.right)(ma.left) : (0, exports.left)(ma.right);
    };
    exports.swap = swap;
    var orElseW2 = function(onLeft) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? onLeft(ma.left) : ma;
      };
    };
    exports.orElseW = orElseW2;
    exports.orElse = exports.orElseW;
    var fromNullable = function(e) {
      return function(a) {
        return a == null ? (0, exports.left)(e) : (0, exports.right)(a);
      };
    };
    exports.fromNullable = fromNullable;
    var tryCatch = function(f, onThrow) {
      try {
        return (0, exports.right)(f());
      } catch (e) {
        return (0, exports.left)(onThrow(e));
      }
    };
    exports.tryCatch = tryCatch;
    var tryCatchK = function(f, onThrow) {
      return function() {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          a[_i] = arguments[_i];
        }
        return (0, exports.tryCatch)(function() {
          return f.apply(void 0, a);
        }, onThrow);
      };
    };
    exports.tryCatchK = tryCatchK;
    var fromNullableK = function(e) {
      var from = (0, exports.fromNullable)(e);
      return function(f) {
        return (0, function_1.flow)(f, from);
      };
    };
    exports.fromNullableK = fromNullableK;
    var chainNullableK = function(e) {
      var from = (0, exports.fromNullableK)(e);
      return function(f) {
        return (0, exports.flatMap)(from(f));
      };
    };
    exports.chainNullableK = chainNullableK;
    exports.toUnion = (0, exports.foldW)(function_1.identity, function_1.identity);
    function toError(e) {
      try {
        return e instanceof Error ? e : new Error(String(e));
      } catch (error) {
        return new Error();
      }
    }
    function elem(E) {
      return function(a, ma) {
        if (ma === void 0) {
          var elemE_1 = elem(E);
          return function(ma2) {
            return elemE_1(a, ma2);
          };
        }
        return (0, exports.isLeft)(ma) ? false : E.equals(a, ma.right);
      };
    }
    var exists = function(predicate) {
      return function(ma) {
        return (0, exports.isLeft)(ma) ? false : predicate(ma.right);
      };
    };
    exports.exists = exists;
    exports.Do = (0, exports.of)(_.emptyRecord);
    exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
    var let_2 = /* @__PURE__ */ (0, Functor_1.let)(exports.Functor);
    exports.let = let_2;
    exports.bind = chainable.bind(exports.Chain);
    exports.bindW = exports.bind;
    exports.apS = (0, Apply_1.apS)(exports.Apply);
    exports.apSW = exports.apS;
    exports.ApT = (0, exports.of)(_.emptyReadonlyArray);
    var traverseReadonlyNonEmptyArrayWithIndex = function(f) {
      return function(as3) {
        var e = f(0, _.head(as3));
        if ((0, exports.isLeft)(e)) {
          return e;
        }
        var out = [e.right];
        for (var i = 1; i < as3.length; i++) {
          var e_1 = f(i, as3[i]);
          if ((0, exports.isLeft)(e_1)) {
            return e_1;
          }
          out.push(e_1.right);
        }
        return (0, exports.right)(out);
      };
    };
    exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
    var traverseReadonlyArrayWithIndex = function(f) {
      var g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
      return function(as3) {
        return _.isNonEmpty(as3) ? g(as3) : exports.ApT;
      };
    };
    exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
    exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
    var traverseArray = function(f) {
      return (0, exports.traverseReadonlyArrayWithIndex)(function(_2, a) {
        return f(a);
      });
    };
    exports.traverseArray = traverseArray;
    exports.sequenceArray = /* @__PURE__ */ (0, exports.traverseArray)(function_1.identity);
    exports.chainW = exports.flatMap;
    exports.chain = exports.flatMap;
    exports.chainFirst = exports.tap;
    exports.chainFirstW = exports.tap;
    function parseJSON(s, onError) {
      return (0, exports.tryCatch)(function() {
        return JSON.parse(s);
      }, onError);
    }
    var stringifyJSON = function(u, onError) {
      return (0, exports.tryCatch)(function() {
        var s = JSON.stringify(u);
        if (typeof s !== "string") {
          throw new Error("Converting unsupported structure to JSON");
        }
        return s;
      }, onError);
    };
    exports.stringifyJSON = stringifyJSON;
    exports.either = {
      URI: exports.URI,
      map: _map2,
      of: exports.of,
      ap: _ap2,
      chain: exports.flatMap,
      reduce: _reduce,
      foldMap: _foldMap,
      reduceRight: _reduceRight,
      traverse: _traverse,
      sequence: exports.sequence,
      bimap: _bimap,
      mapLeft: _mapLeft,
      alt: _alt,
      extend: _extend,
      chainRec: _chainRec,
      throwError: exports.throwError
    };
    exports.getApplySemigroup = /* @__PURE__ */ (0, Apply_1.getApplySemigroup)(exports.Apply);
    exports.getApplyMonoid = /* @__PURE__ */ (0, Applicative_1.getApplicativeMonoid)(exports.Applicative);
    var getValidationSemigroup = function(SE, SA) {
      return (0, Apply_1.getApplySemigroup)((0, exports.getApplicativeValidation)(SE))(SA);
    };
    exports.getValidationSemigroup = getValidationSemigroup;
    var getValidationMonoid = function(SE, MA) {
      return (0, Applicative_1.getApplicativeMonoid)((0, exports.getApplicativeValidation)(SE))(MA);
    };
    exports.getValidationMonoid = getValidationMonoid;
    function getValidation(SE) {
      var ap2 = (0, exports.getApplicativeValidation)(SE).ap;
      var alt = (0, exports.getAltValidation)(SE).alt;
      return {
        URI: exports.URI,
        _E: void 0,
        map: _map2,
        of: exports.of,
        chain: exports.flatMap,
        bimap: _bimap,
        mapLeft: _mapLeft,
        reduce: _reduce,
        foldMap: _foldMap,
        reduceRight: _reduceRight,
        extend: _extend,
        traverse: _traverse,
        sequence: exports.sequence,
        chainRec: _chainRec,
        throwError: exports.throwError,
        ap: ap2,
        alt
      };
    }
  }
});

// node_modules/.pnpm/io-ts@2.2.21_fp-ts@2.16.8/node_modules/io-ts/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/io-ts@2.2.21_fp-ts@2.16.8/node_modules/io-ts/lib/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p3 in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p3))
              d2[p3] = b2[p3];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t5) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p3 in s)
            if (Object.prototype.hasOwnProperty.call(s, p3))
              t5[p3] = s[p3];
        }
        return t5;
      };
      return __assign.apply(this, arguments);
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.partial = exports.PartialType = exports.type = exports.InterfaceType = exports.array = exports.ArrayType = exports.recursion = exports.RecursiveType = exports.Int = exports.brand = exports.RefinementType = exports.keyof = exports.KeyofType = exports.literal = exports.LiteralType = exports.void = exports.undefined = exports.null = exports.UnknownRecord = exports.AnyDictionaryType = exports.UnknownArray = exports.AnyArrayType = exports.boolean = exports.BooleanType = exports.bigint = exports.BigIntType = exports.number = exports.NumberType = exports.string = exports.StringType = exports.unknown = exports.UnknownType = exports.voidType = exports.VoidType = exports.UndefinedType = exports.nullType = exports.NullType = exports.getIndex = exports.getTags = exports.emptyTags = exports.mergeAll = exports.getDomainKeys = exports.appendContext = exports.getContextEntry = exports.getFunctionName = exports.identity = exports.Type = exports.success = exports.failure = exports.failures = void 0;
    exports.alias = exports.clean = exports.StrictType = exports.dictionary = exports.object = exports.ObjectType = exports.Dictionary = exports.getDefaultContext = exports.getValidationError = exports.interface = exports.Array = exports.taggedUnion = exports.TaggedUnionType = exports.Integer = exports.refinement = exports.any = exports.AnyType = exports.never = exports.NeverType = exports.Function = exports.FunctionType = exports.exact = exports.ExactType = exports.strict = exports.readonlyArray = exports.ReadonlyArrayType = exports.readonly = exports.ReadonlyType = exports.tuple = exports.TupleType = exports.intersection = exports.IntersectionType = exports.union = exports.UnionType = exports.record = exports.DictionaryType = void 0;
    var Either_1 = require_Either();
    exports.failures = Either_1.left;
    var failure = function(value2, context, message) {
      return (0, exports.failures)([{ value: value2, context, message }]);
    };
    exports.failure = failure;
    exports.success = Either_1.right;
    var Type = (
      /** @class */
      function() {
        function Type2(name, is, validate, encode) {
          this.name = name;
          this.is = is;
          this.validate = validate;
          this.encode = encode;
          this.decode = this.decode.bind(this);
        }
        Type2.prototype.pipe = function(ab, name) {
          var _this = this;
          if (name === void 0) {
            name = "pipe(".concat(this.name, ", ").concat(ab.name, ")");
          }
          return new Type2(name, ab.is, function(i, c) {
            var e = _this.validate(i, c);
            if ((0, Either_1.isLeft)(e)) {
              return e;
            }
            return ab.validate(e.right, c);
          }, this.encode === exports.identity && ab.encode === exports.identity ? exports.identity : function(b) {
            return _this.encode(ab.encode(b));
          });
        };
        Type2.prototype.asDecoder = function() {
          return this;
        };
        Type2.prototype.asEncoder = function() {
          return this;
        };
        Type2.prototype.decode = function(i) {
          return this.validate(i, [{ key: "", type: this, actual: i }]);
        };
        return Type2;
      }()
    );
    exports.Type = Type;
    var identity2 = function(a) {
      return a;
    };
    exports.identity = identity2;
    function getFunctionName(f) {
      return f.displayName || f.name || "<function".concat(f.length, ">");
    }
    exports.getFunctionName = getFunctionName;
    function getContextEntry(key, decoder) {
      return { key, type: decoder };
    }
    exports.getContextEntry = getContextEntry;
    function appendContext(c, key, decoder, actual) {
      var len = c.length;
      var r = Array(len + 1);
      for (var i = 0; i < len; i++) {
        r[i] = c[i];
      }
      r[len] = { key, type: decoder, actual };
      return r;
    }
    exports.appendContext = appendContext;
    function pushAll(xs, ys) {
      var l = ys.length;
      for (var i = 0; i < l; i++) {
        xs.push(ys[i]);
      }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function getNameFromProps(props) {
      return Object.keys(props).map(function(k) {
        return "".concat(k, ": ").concat(props[k].name);
      }).join(", ");
    }
    function useIdentity(codecs) {
      for (var i = 0; i < codecs.length; i++) {
        if (codecs[i].encode !== exports.identity) {
          return false;
        }
      }
      return true;
    }
    function getInterfaceTypeName(props) {
      return "{ ".concat(getNameFromProps(props), " }");
    }
    function getPartialTypeName(inner) {
      return "Partial<".concat(inner, ">");
    }
    function enumerableRecord(keys, domain, codomain, name) {
      if (name === void 0) {
        name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
      }
      var len = keys.length;
      var props = {};
      for (var i = 0; i < len; i++) {
        props[keys[i]] = codomain;
      }
      var exactCodec = (0, exports.strict)(props, name);
      return new DictionaryType(name, function(u) {
        return exactCodec.is(u);
      }, exactCodec.validate, exactCodec.encode, domain, codomain);
    }
    function getDomainKeys(domain) {
      var _a;
      if (isLiteralC(domain)) {
        var literal_1 = domain.value;
        if (exports.string.is(literal_1)) {
          return _a = {}, _a[literal_1] = null, _a;
        }
      } else if (isKeyofC(domain)) {
        return domain.keys;
      } else if (isUnionC(domain)) {
        var keys = domain.types.map(function(type4) {
          return getDomainKeys(type4);
        });
        return keys.some(undefinedType.is) ? void 0 : Object.assign.apply(Object, __spreadArray2([{}], keys, false));
      }
      return void 0;
    }
    exports.getDomainKeys = getDomainKeys;
    function stripNonDomainKeys(o, domain) {
      var keys = Object.keys(o);
      var len = keys.length;
      var shouldStrip = false;
      var r = {};
      for (var i = 0; i < len; i++) {
        var k = keys[i];
        if (domain.is(k)) {
          r[k] = o[k];
        } else {
          shouldStrip = true;
        }
      }
      return shouldStrip ? r : o;
    }
    function nonEnumerableRecord(domain, codomain, name) {
      if (name === void 0) {
        name = "{ [K in ".concat(domain.name, "]: ").concat(codomain.name, " }");
      }
      return new DictionaryType(name, function(u) {
        if (exports.UnknownRecord.is(u)) {
          return Object.keys(u).every(function(k) {
            return !domain.is(k) || codomain.is(u[k]);
          });
        }
        return isAnyC(codomain) && Array.isArray(u);
      }, function(u, c) {
        if (exports.UnknownRecord.is(u)) {
          var a = {};
          var errors = [];
          var keys = Object.keys(u);
          var len = keys.length;
          var changed = false;
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var ok = u[k];
            var domainResult = domain.validate(k, appendContext(c, k, domain, k));
            if ((0, Either_1.isLeft)(domainResult)) {
              changed = true;
            } else {
              var vk = domainResult.right;
              changed = changed || vk !== k;
              k = vk;
              var codomainResult = codomain.validate(ok, appendContext(c, k, codomain, ok));
              if ((0, Either_1.isLeft)(codomainResult)) {
                pushAll(errors, codomainResult.left);
              } else {
                var vok = codomainResult.right;
                changed = changed || vok !== ok;
                a[k] = vok;
              }
            }
          }
          return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(changed ? a : u);
        }
        if (isAnyC(codomain) && Array.isArray(u)) {
          return (0, exports.success)(u);
        }
        return (0, exports.failure)(u, c);
      }, domain.encode === exports.identity && codomain.encode === exports.identity ? function(a) {
        return stripNonDomainKeys(a, domain);
      } : function(a) {
        var s = {};
        var keys = Object.keys(stripNonDomainKeys(a, domain));
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          var k = keys[i];
          s[String(domain.encode(k))] = codomain.encode(a[k]);
        }
        return s;
      }, domain, codomain);
    }
    function getUnionName(codecs) {
      return "(" + codecs.map(function(type4) {
        return type4.name;
      }).join(" | ") + ")";
    }
    function mergeAll(base, us) {
      var equal = true;
      var primitive = true;
      var baseIsNotADictionary = !exports.UnknownRecord.is(base);
      for (var _i = 0, us_1 = us; _i < us_1.length; _i++) {
        var u = us_1[_i];
        if (u !== base) {
          equal = false;
        }
        if (exports.UnknownRecord.is(u)) {
          primitive = false;
        }
      }
      if (equal) {
        return base;
      } else if (primitive) {
        return us[us.length - 1];
      }
      var r = {};
      for (var _a = 0, us_2 = us; _a < us_2.length; _a++) {
        var u = us_2[_a];
        for (var k in u) {
          if (!hasOwnProperty.call(r, k) || baseIsNotADictionary || u[k] !== base[k]) {
            r[k] = u[k];
          }
        }
      }
      return r;
    }
    exports.mergeAll = mergeAll;
    function getProps(codec) {
      switch (codec._tag) {
        case "RefinementType":
        case "ReadonlyType":
          return getProps(codec.type);
        case "InterfaceType":
        case "StrictType":
        case "PartialType":
          return codec.props;
        case "IntersectionType":
          return codec.types.reduce(function(props, type4) {
            return Object.assign(props, getProps(type4));
          }, {});
      }
    }
    function stripKeys(o, props) {
      var keys = Object.getOwnPropertyNames(o);
      var shouldStrip = false;
      var r = {};
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwnProperty.call(props, key)) {
          shouldStrip = true;
        } else {
          r[key] = o[key];
        }
      }
      return shouldStrip ? r : o;
    }
    function getExactTypeName(codec) {
      if (isTypeC(codec)) {
        return "{| ".concat(getNameFromProps(codec.props), " |}");
      } else if (isPartialC(codec)) {
        return getPartialTypeName("{| ".concat(getNameFromProps(codec.props), " |}"));
      }
      return "Exact<".concat(codec.name, ">");
    }
    function isNonEmpty2(as3) {
      return as3.length > 0;
    }
    exports.emptyTags = {};
    function intersect(a, b) {
      var r = [];
      for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
        var v = a_1[_i];
        if (b.indexOf(v) !== -1) {
          r.push(v);
        }
      }
      return r;
    }
    function mergeTags(a, b) {
      if (a === exports.emptyTags) {
        return b;
      }
      if (b === exports.emptyTags) {
        return a;
      }
      var r = Object.assign({}, a);
      for (var k in b) {
        if (hasOwnProperty.call(a, k)) {
          var intersection_1 = intersect(a[k], b[k]);
          if (isNonEmpty2(intersection_1)) {
            r[k] = intersection_1;
          } else {
            r = exports.emptyTags;
            break;
          }
        } else {
          r[k] = b[k];
        }
      }
      return r;
    }
    function intersectTags(a, b) {
      if (a === exports.emptyTags || b === exports.emptyTags) {
        return exports.emptyTags;
      }
      var r = exports.emptyTags;
      for (var k in a) {
        if (hasOwnProperty.call(b, k)) {
          var intersection_2 = intersect(a[k], b[k]);
          if (intersection_2.length === 0) {
            if (r === exports.emptyTags) {
              r = {};
            }
            r[k] = a[k].concat(b[k]);
          }
        }
      }
      return r;
    }
    function isAnyC(codec) {
      return codec._tag === "AnyType";
    }
    function isLiteralC(codec) {
      return codec._tag === "LiteralType";
    }
    function isKeyofC(codec) {
      return codec._tag === "KeyofType";
    }
    function isTypeC(codec) {
      return codec._tag === "InterfaceType";
    }
    function isPartialC(codec) {
      return codec._tag === "PartialType";
    }
    function isStrictC(codec) {
      return codec._tag === "StrictType";
    }
    function isExactC(codec) {
      return codec._tag === "ExactType";
    }
    function isRefinementC(codec) {
      return codec._tag === "RefinementType";
    }
    function isIntersectionC(codec) {
      return codec._tag === "IntersectionType";
    }
    function isUnionC(codec) {
      return codec._tag === "UnionType";
    }
    function isRecursiveC(codec) {
      return codec._tag === "RecursiveType";
    }
    var lazyCodecs = [];
    function getTags(codec) {
      if (lazyCodecs.indexOf(codec) !== -1) {
        return exports.emptyTags;
      }
      if (isTypeC(codec) || isStrictC(codec)) {
        var index = exports.emptyTags;
        for (var k in codec.props) {
          var prop = codec.props[k];
          if (isLiteralC(prop)) {
            if (index === exports.emptyTags) {
              index = {};
            }
            index[k] = [prop.value];
          }
        }
        return index;
      } else if (isExactC(codec) || isRefinementC(codec)) {
        return getTags(codec.type);
      } else if (isIntersectionC(codec)) {
        return codec.types.reduce(function(tags2, codec2) {
          return mergeTags(tags2, getTags(codec2));
        }, exports.emptyTags);
      } else if (isUnionC(codec)) {
        return codec.types.slice(1).reduce(function(tags2, codec2) {
          return intersectTags(tags2, getTags(codec2));
        }, getTags(codec.types[0]));
      } else if (isRecursiveC(codec)) {
        lazyCodecs.push(codec);
        var tags = getTags(codec.type);
        lazyCodecs.pop();
        return tags;
      }
      return exports.emptyTags;
    }
    exports.getTags = getTags;
    function getIndex(codecs) {
      var tags = getTags(codecs[0]);
      var keys = Object.keys(tags);
      var len = codecs.length;
      var _loop_1 = function(k2) {
        var all = tags[k2].slice();
        var index = [tags[k2]];
        for (var i = 1; i < len; i++) {
          var codec = codecs[i];
          var ctags = getTags(codec);
          var values = ctags[k2];
          if (values === void 0) {
            return "continue-keys";
          } else {
            if (values.some(function(v) {
              return all.indexOf(v) !== -1;
            })) {
              return "continue-keys";
            } else {
              all.push.apply(all, values);
              index.push(values);
            }
          }
        }
        return { value: [k2, index] };
      };
      keys:
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
          var k = keys_1[_i];
          var state_1 = _loop_1(k);
          if (typeof state_1 === "object")
            return state_1.value;
          switch (state_1) {
            case "continue-keys":
              continue keys;
          }
        }
      return void 0;
    }
    exports.getIndex = getIndex;
    var NullType = (
      /** @class */
      function(_super) {
        __extends(NullType2, _super);
        function NullType2() {
          var _this = _super.call(this, "null", function(u) {
            return u === null;
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "NullType";
          return _this;
        }
        return NullType2;
      }(Type)
    );
    exports.NullType = NullType;
    exports.nullType = new NullType();
    exports.null = exports.nullType;
    var UndefinedType = (
      /** @class */
      function(_super) {
        __extends(UndefinedType2, _super);
        function UndefinedType2() {
          var _this = _super.call(this, "undefined", function(u) {
            return u === void 0;
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "UndefinedType";
          return _this;
        }
        return UndefinedType2;
      }(Type)
    );
    exports.UndefinedType = UndefinedType;
    var undefinedType = new UndefinedType();
    exports.undefined = undefinedType;
    var VoidType = (
      /** @class */
      function(_super) {
        __extends(VoidType2, _super);
        function VoidType2() {
          var _this = _super.call(this, "void", undefinedType.is, undefinedType.validate, exports.identity) || this;
          _this._tag = "VoidType";
          return _this;
        }
        return VoidType2;
      }(Type)
    );
    exports.VoidType = VoidType;
    exports.voidType = new VoidType();
    exports.void = exports.voidType;
    var UnknownType = (
      /** @class */
      function(_super) {
        __extends(UnknownType2, _super);
        function UnknownType2() {
          var _this = _super.call(this, "unknown", function(_) {
            return true;
          }, exports.success, exports.identity) || this;
          _this._tag = "UnknownType";
          return _this;
        }
        return UnknownType2;
      }(Type)
    );
    exports.UnknownType = UnknownType;
    exports.unknown = new UnknownType();
    var StringType = (
      /** @class */
      function(_super) {
        __extends(StringType2, _super);
        function StringType2() {
          var _this = _super.call(this, "string", function(u) {
            return typeof u === "string";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "StringType";
          return _this;
        }
        return StringType2;
      }(Type)
    );
    exports.StringType = StringType;
    exports.string = new StringType();
    var NumberType = (
      /** @class */
      function(_super) {
        __extends(NumberType2, _super);
        function NumberType2() {
          var _this = _super.call(this, "number", function(u) {
            return typeof u === "number";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "NumberType";
          return _this;
        }
        return NumberType2;
      }(Type)
    );
    exports.NumberType = NumberType;
    exports.number = new NumberType();
    var BigIntType = (
      /** @class */
      function(_super) {
        __extends(BigIntType2, _super);
        function BigIntType2() {
          var _this = _super.call(
            this,
            "bigint",
            // tslint:disable-next-line: valid-typeof
            function(u) {
              return typeof u === "bigint";
            },
            function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            },
            exports.identity
          ) || this;
          _this._tag = "BigIntType";
          return _this;
        }
        return BigIntType2;
      }(Type)
    );
    exports.BigIntType = BigIntType;
    exports.bigint = new BigIntType();
    var BooleanType = (
      /** @class */
      function(_super) {
        __extends(BooleanType2, _super);
        function BooleanType2() {
          var _this = _super.call(this, "boolean", function(u) {
            return typeof u === "boolean";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "BooleanType";
          return _this;
        }
        return BooleanType2;
      }(Type)
    );
    exports.BooleanType = BooleanType;
    exports.boolean = new BooleanType();
    var AnyArrayType = (
      /** @class */
      function(_super) {
        __extends(AnyArrayType2, _super);
        function AnyArrayType2() {
          var _this = _super.call(this, "UnknownArray", Array.isArray, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "AnyArrayType";
          return _this;
        }
        return AnyArrayType2;
      }(Type)
    );
    exports.AnyArrayType = AnyArrayType;
    exports.UnknownArray = new AnyArrayType();
    exports.Array = exports.UnknownArray;
    var AnyDictionaryType = (
      /** @class */
      function(_super) {
        __extends(AnyDictionaryType2, _super);
        function AnyDictionaryType2() {
          var _this = _super.call(this, "UnknownRecord", function(u) {
            return u !== null && typeof u === "object" && !Array.isArray(u);
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "AnyDictionaryType";
          return _this;
        }
        return AnyDictionaryType2;
      }(Type)
    );
    exports.AnyDictionaryType = AnyDictionaryType;
    exports.UnknownRecord = new AnyDictionaryType();
    var LiteralType = (
      /** @class */
      function(_super) {
        __extends(LiteralType2, _super);
        function LiteralType2(name, is, validate, encode, value2) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.value = value2;
          _this._tag = "LiteralType";
          return _this;
        }
        return LiteralType2;
      }(Type)
    );
    exports.LiteralType = LiteralType;
    function literal3(value2, name) {
      if (name === void 0) {
        name = JSON.stringify(value2);
      }
      var is = function(u) {
        return u === value2;
      };
      return new LiteralType(name, is, function(u, c) {
        return is(u) ? (0, exports.success)(value2) : (0, exports.failure)(u, c);
      }, exports.identity, value2);
    }
    exports.literal = literal3;
    var KeyofType = (
      /** @class */
      function(_super) {
        __extends(KeyofType2, _super);
        function KeyofType2(name, is, validate, encode, keys) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.keys = keys;
          _this._tag = "KeyofType";
          return _this;
        }
        return KeyofType2;
      }(Type)
    );
    exports.KeyofType = KeyofType;
    function keyof(keys, name) {
      if (name === void 0) {
        name = Object.keys(keys).map(function(k) {
          return JSON.stringify(k);
        }).join(" | ");
      }
      var is = function(u) {
        return exports.string.is(u) && hasOwnProperty.call(keys, u);
      };
      return new KeyofType(name, is, function(u, c) {
        return is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
      }, exports.identity, keys);
    }
    exports.keyof = keyof;
    var RefinementType = (
      /** @class */
      function(_super) {
        __extends(RefinementType2, _super);
        function RefinementType2(name, is, validate, encode, type4, predicate) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this.predicate = predicate;
          _this._tag = "RefinementType";
          return _this;
        }
        return RefinementType2;
      }(Type)
    );
    exports.RefinementType = RefinementType;
    function brand(codec, predicate, name) {
      return refinement(codec, predicate, name);
    }
    exports.brand = brand;
    exports.Int = brand(exports.number, function(n) {
      return Number.isInteger(n);
    }, "Int");
    var RecursiveType = (
      /** @class */
      function(_super) {
        __extends(RecursiveType2, _super);
        function RecursiveType2(name, is, validate, encode, runDefinition) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.runDefinition = runDefinition;
          _this._tag = "RecursiveType";
          return _this;
        }
        return RecursiveType2;
      }(Type)
    );
    exports.RecursiveType = RecursiveType;
    Object.defineProperty(RecursiveType.prototype, "type", {
      get: function() {
        return this.runDefinition();
      },
      enumerable: true,
      configurable: true
    });
    function recursion2(name, definition) {
      var cache;
      var runDefinition = function() {
        if (!cache) {
          cache = definition(Self);
          cache.name = name;
        }
        return cache;
      };
      var Self = new RecursiveType(name, function(u) {
        return runDefinition().is(u);
      }, function(u, c) {
        return runDefinition().validate(u, c);
      }, function(a) {
        return runDefinition().encode(a);
      }, runDefinition);
      return Self;
    }
    exports.recursion = recursion2;
    var ArrayType = (
      /** @class */
      function(_super) {
        __extends(ArrayType2, _super);
        function ArrayType2(name, is, validate, encode, type4) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this._tag = "ArrayType";
          return _this;
        }
        return ArrayType2;
      }(Type)
    );
    exports.ArrayType = ArrayType;
    function array2(item, name) {
      if (name === void 0) {
        name = "Array<".concat(item.name, ">");
      }
      return new ArrayType(name, function(u) {
        return exports.UnknownArray.is(u) && u.every(item.is);
      }, function(u, c) {
        var e = exports.UnknownArray.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var us = e.right;
        var len = us.length;
        var as3 = us;
        var errors = [];
        for (var i = 0; i < len; i++) {
          var ui = us[i];
          var result = item.validate(ui, appendContext(c, String(i), item, ui));
          if ((0, Either_1.isLeft)(result)) {
            pushAll(errors, result.left);
          } else {
            var ai = result.right;
            if (ai !== ui) {
              if (as3 === us) {
                as3 = us.slice();
              }
              as3[i] = ai;
            }
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as3);
      }, item.encode === exports.identity ? exports.identity : function(a) {
        return a.map(item.encode);
      }, item);
    }
    exports.array = array2;
    var InterfaceType = (
      /** @class */
      function(_super) {
        __extends(InterfaceType2, _super);
        function InterfaceType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "InterfaceType";
          return _this;
        }
        return InterfaceType2;
      }(Type)
    );
    exports.InterfaceType = InterfaceType;
    function type3(props, name) {
      if (name === void 0) {
        name = getInterfaceTypeName(props);
      }
      var keys = Object.keys(props);
      var types = keys.map(function(key) {
        return props[key];
      });
      var len = keys.length;
      return new InterfaceType(name, function(u) {
        if (exports.UnknownRecord.is(u)) {
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var uk = u[k];
            if (uk === void 0 && !hasOwnProperty.call(u, k) || !types[i].is(uk)) {
              return false;
            }
          }
          return true;
        }
        return false;
      }, function(u, c) {
        var e = exports.UnknownRecord.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var o = e.right;
        var a = o;
        var errors = [];
        for (var i = 0; i < len; i++) {
          var k = keys[i];
          var ak = a[k];
          var type_1 = types[i];
          var result = type_1.validate(ak, appendContext(c, k, type_1, ak));
          if ((0, Either_1.isLeft)(result)) {
            pushAll(errors, result.left);
          } else {
            var vak = result.right;
            if (vak !== ak || vak === void 0 && !hasOwnProperty.call(a, k)) {
              if (a === o) {
                a = __assign({}, o);
              }
              a[k] = vak;
            }
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a);
      }, useIdentity(types) ? exports.identity : function(a) {
        var s = __assign({}, a);
        for (var i = 0; i < len; i++) {
          var k = keys[i];
          var encode = types[i].encode;
          if (encode !== exports.identity) {
            s[k] = encode(a[k]);
          }
        }
        return s;
      }, props);
    }
    exports.type = type3;
    exports.interface = type3;
    var PartialType = (
      /** @class */
      function(_super) {
        __extends(PartialType2, _super);
        function PartialType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "PartialType";
          return _this;
        }
        return PartialType2;
      }(Type)
    );
    exports.PartialType = PartialType;
    function partial(props, name) {
      if (name === void 0) {
        name = getPartialTypeName(getInterfaceTypeName(props));
      }
      var keys = Object.keys(props);
      var types = keys.map(function(key) {
        return props[key];
      });
      var len = keys.length;
      return new PartialType(name, function(u) {
        if (exports.UnknownRecord.is(u)) {
          for (var i = 0; i < len; i++) {
            var k = keys[i];
            var uk = u[k];
            if (uk !== void 0 && !props[k].is(uk)) {
              return false;
            }
          }
          return true;
        }
        return false;
      }, function(u, c) {
        var e = exports.UnknownRecord.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var o = e.right;
        var a = o;
        var errors = [];
        for (var i = 0; i < len; i++) {
          var k = keys[i];
          var ak = a[k];
          var type_2 = props[k];
          var result = type_2.validate(ak, appendContext(c, k, type_2, ak));
          if ((0, Either_1.isLeft)(result)) {
            if (ak !== void 0) {
              pushAll(errors, result.left);
            }
          } else {
            var vak = result.right;
            if (vak !== ak) {
              if (a === o) {
                a = __assign({}, o);
              }
              a[k] = vak;
            }
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(a);
      }, useIdentity(types) ? exports.identity : function(a) {
        var s = __assign({}, a);
        for (var i = 0; i < len; i++) {
          var k = keys[i];
          var ak = a[k];
          if (ak !== void 0) {
            s[k] = types[i].encode(ak);
          }
        }
        return s;
      }, props);
    }
    exports.partial = partial;
    var DictionaryType = (
      /** @class */
      function(_super) {
        __extends(DictionaryType2, _super);
        function DictionaryType2(name, is, validate, encode, domain, codomain) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.domain = domain;
          _this.codomain = codomain;
          _this._tag = "DictionaryType";
          return _this;
        }
        return DictionaryType2;
      }(Type)
    );
    exports.DictionaryType = DictionaryType;
    function record2(domain, codomain, name) {
      var keys = getDomainKeys(domain);
      return keys ? enumerableRecord(Object.keys(keys), domain, codomain, name) : nonEnumerableRecord(domain, codomain, name);
    }
    exports.record = record2;
    var UnionType = (
      /** @class */
      function(_super) {
        __extends(UnionType2, _super);
        function UnionType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "UnionType";
          return _this;
        }
        return UnionType2;
      }(Type)
    );
    exports.UnionType = UnionType;
    function union3(codecs, name) {
      if (name === void 0) {
        name = getUnionName(codecs);
      }
      var index = getIndex(codecs);
      if (index !== void 0 && codecs.length > 0) {
        var tag_1 = index[0], groups_1 = index[1];
        var len_1 = groups_1.length;
        var find_1 = function(value2) {
          for (var i = 0; i < len_1; i++) {
            if (groups_1[i].indexOf(value2) !== -1) {
              return i;
            }
          }
          return void 0;
        };
        return new TaggedUnionType(name, function(u) {
          if (exports.UnknownRecord.is(u)) {
            var i = find_1(u[tag_1]);
            return i !== void 0 ? codecs[i].is(u) : false;
          }
          return false;
        }, function(u, c) {
          var e = exports.UnknownRecord.validate(u, c);
          if ((0, Either_1.isLeft)(e)) {
            return e;
          }
          var r = e.right;
          var i = find_1(r[tag_1]);
          if (i === void 0) {
            return (0, exports.failure)(u, c);
          }
          var codec = codecs[i];
          return codec.validate(r, appendContext(c, String(i), codec, r));
        }, useIdentity(codecs) ? exports.identity : function(a) {
          var i = find_1(a[tag_1]);
          if (i === void 0) {
            throw new Error("no codec found to encode value in union codec ".concat(name));
          } else {
            return codecs[i].encode(a);
          }
        }, codecs, tag_1);
      } else {
        return new UnionType(name, function(u) {
          return codecs.some(function(type4) {
            return type4.is(u);
          });
        }, function(u, c) {
          var errors = [];
          for (var i = 0; i < codecs.length; i++) {
            var codec = codecs[i];
            var result = codec.validate(u, appendContext(c, String(i), codec, u));
            if ((0, Either_1.isLeft)(result)) {
              pushAll(errors, result.left);
            } else {
              return (0, exports.success)(result.right);
            }
          }
          return (0, exports.failures)(errors);
        }, useIdentity(codecs) ? exports.identity : function(a) {
          for (var _i = 0, codecs_1 = codecs; _i < codecs_1.length; _i++) {
            var codec = codecs_1[_i];
            if (codec.is(a)) {
              return codec.encode(a);
            }
          }
          throw new Error("no codec found to encode value in union type ".concat(name));
        }, codecs);
      }
    }
    exports.union = union3;
    var IntersectionType = (
      /** @class */
      function(_super) {
        __extends(IntersectionType2, _super);
        function IntersectionType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "IntersectionType";
          return _this;
        }
        return IntersectionType2;
      }(Type)
    );
    exports.IntersectionType = IntersectionType;
    function intersection(codecs, name) {
      if (name === void 0) {
        name = "(".concat(codecs.map(function(type4) {
          return type4.name;
        }).join(" & "), ")");
      }
      var len = codecs.length;
      return new IntersectionType(name, function(u) {
        return codecs.every(function(type4) {
          return type4.is(u);
        });
      }, codecs.length === 0 ? exports.success : function(u, c) {
        var us = [];
        var errors = [];
        for (var i = 0; i < len; i++) {
          var codec = codecs[i];
          var result = codec.validate(u, appendContext(c, String(i), codec, u));
          if ((0, Either_1.isLeft)(result)) {
            pushAll(errors, result.left);
          } else {
            us.push(result.right);
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(mergeAll(u, us));
      }, codecs.length === 0 ? exports.identity : function(a) {
        return mergeAll(a, codecs.map(function(codec) {
          return codec.encode(a);
        }));
      }, codecs);
    }
    exports.intersection = intersection;
    var TupleType = (
      /** @class */
      function(_super) {
        __extends(TupleType2, _super);
        function TupleType2(name, is, validate, encode, types) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.types = types;
          _this._tag = "TupleType";
          return _this;
        }
        return TupleType2;
      }(Type)
    );
    exports.TupleType = TupleType;
    function tuple(codecs, name) {
      if (name === void 0) {
        name = "[".concat(codecs.map(function(type4) {
          return type4.name;
        }).join(", "), "]");
      }
      var len = codecs.length;
      return new TupleType(name, function(u) {
        return exports.UnknownArray.is(u) && u.length === len && codecs.every(function(type4, i) {
          return type4.is(u[i]);
        });
      }, function(u, c) {
        var e = exports.UnknownArray.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var us = e.right;
        var as3 = us.length > len ? us.slice(0, len) : us;
        var errors = [];
        for (var i = 0; i < len; i++) {
          var a = us[i];
          var type_3 = codecs[i];
          var result = type_3.validate(a, appendContext(c, String(i), type_3, a));
          if ((0, Either_1.isLeft)(result)) {
            pushAll(errors, result.left);
          } else {
            var va = result.right;
            if (va !== a) {
              if (as3 === us) {
                as3 = us.slice();
              }
              as3[i] = va;
            }
          }
        }
        return errors.length > 0 ? (0, exports.failures)(errors) : (0, exports.success)(as3);
      }, useIdentity(codecs) ? exports.identity : function(a) {
        return codecs.map(function(type4, i) {
          return type4.encode(a[i]);
        });
      }, codecs);
    }
    exports.tuple = tuple;
    var ReadonlyType = (
      /** @class */
      function(_super) {
        __extends(ReadonlyType2, _super);
        function ReadonlyType2(name, is, validate, encode, type4) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this._tag = "ReadonlyType";
          return _this;
        }
        return ReadonlyType2;
      }(Type)
    );
    exports.ReadonlyType = ReadonlyType;
    function readonly(codec, name) {
      if (name === void 0) {
        name = "Readonly<".concat(codec.name, ">");
      }
      return new ReadonlyType(name, codec.is, codec.validate, codec.encode, codec);
    }
    exports.readonly = readonly;
    var ReadonlyArrayType = (
      /** @class */
      function(_super) {
        __extends(ReadonlyArrayType2, _super);
        function ReadonlyArrayType2(name, is, validate, encode, type4) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this._tag = "ReadonlyArrayType";
          return _this;
        }
        return ReadonlyArrayType2;
      }(Type)
    );
    exports.ReadonlyArrayType = ReadonlyArrayType;
    function readonlyArray(item, name) {
      if (name === void 0) {
        name = "ReadonlyArray<".concat(item.name, ">");
      }
      var codec = array2(item);
      return new ReadonlyArrayType(name, codec.is, codec.validate, codec.encode, item);
    }
    exports.readonlyArray = readonlyArray;
    var strict2 = function(props, name) {
      return exact(type3(props), name);
    };
    exports.strict = strict2;
    var ExactType = (
      /** @class */
      function(_super) {
        __extends(ExactType2, _super);
        function ExactType2(name, is, validate, encode, type4) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.type = type4;
          _this._tag = "ExactType";
          return _this;
        }
        return ExactType2;
      }(Type)
    );
    exports.ExactType = ExactType;
    function exact(codec, name) {
      if (name === void 0) {
        name = getExactTypeName(codec);
      }
      var props = getProps(codec);
      return new ExactType(name, codec.is, function(u, c) {
        var e = exports.UnknownRecord.validate(u, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var ce = codec.validate(u, c);
        if ((0, Either_1.isLeft)(ce)) {
          return ce;
        }
        return (0, Either_1.right)(stripKeys(ce.right, props));
      }, function(a) {
        return codec.encode(stripKeys(a, props));
      }, codec);
    }
    exports.exact = exact;
    var FunctionType = (
      /** @class */
      function(_super) {
        __extends(FunctionType2, _super);
        function FunctionType2() {
          var _this = _super.call(
            this,
            "Function",
            // tslint:disable-next-line:strict-type-predicates
            function(u) {
              return typeof u === "function";
            },
            function(u, c) {
              return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
            },
            exports.identity
          ) || this;
          _this._tag = "FunctionType";
          return _this;
        }
        return FunctionType2;
      }(Type)
    );
    exports.FunctionType = FunctionType;
    exports.Function = new FunctionType();
    var NeverType = (
      /** @class */
      function(_super) {
        __extends(NeverType2, _super);
        function NeverType2() {
          var _this = _super.call(
            this,
            "never",
            function(_) {
              return false;
            },
            function(u, c) {
              return (0, exports.failure)(u, c);
            },
            /* istanbul ignore next */
            function() {
              throw new Error("cannot encode never");
            }
          ) || this;
          _this._tag = "NeverType";
          return _this;
        }
        return NeverType2;
      }(Type)
    );
    exports.NeverType = NeverType;
    exports.never = new NeverType();
    var AnyType = (
      /** @class */
      function(_super) {
        __extends(AnyType2, _super);
        function AnyType2() {
          var _this = _super.call(this, "any", function(_) {
            return true;
          }, exports.success, exports.identity) || this;
          _this._tag = "AnyType";
          return _this;
        }
        return AnyType2;
      }(Type)
    );
    exports.AnyType = AnyType;
    exports.any = new AnyType();
    function refinement(codec, predicate, name) {
      if (name === void 0) {
        name = "(".concat(codec.name, " | ").concat(getFunctionName(predicate), ")");
      }
      return new RefinementType(name, function(u) {
        return codec.is(u) && predicate(u);
      }, function(i, c) {
        var e = codec.validate(i, c);
        if ((0, Either_1.isLeft)(e)) {
          return e;
        }
        var a = e.right;
        return predicate(a) ? (0, exports.success)(a) : (0, exports.failure)(a, c);
      }, codec.encode, codec, predicate);
    }
    exports.refinement = refinement;
    exports.Integer = refinement(exports.number, Number.isInteger, "Integer");
    var TaggedUnionType = (
      /** @class */
      function(_super) {
        __extends(TaggedUnionType2, _super);
        function TaggedUnionType2(name, is, validate, encode, codecs, tag2) {
          var _this = _super.call(this, name, is, validate, encode, codecs) || this;
          _this.tag = tag2;
          return _this;
        }
        return TaggedUnionType2;
      }(UnionType)
    );
    exports.TaggedUnionType = TaggedUnionType;
    var taggedUnion = function(tag2, codecs, name) {
      if (name === void 0) {
        name = getUnionName(codecs);
      }
      var U = union3(codecs, name);
      if (U instanceof TaggedUnionType) {
        return U;
      } else {
        console.warn("[io-ts] Cannot build a tagged union for ".concat(name, ", returning a de-optimized union"));
        return new TaggedUnionType(name, U.is, U.validate, U.encode, codecs, tag2);
      }
    };
    exports.taggedUnion = taggedUnion;
    var getValidationError = function(value2, context) {
      return {
        value: value2,
        context
      };
    };
    exports.getValidationError = getValidationError;
    var getDefaultContext2 = function(decoder) {
      return [
        { key: "", type: decoder }
      ];
    };
    exports.getDefaultContext = getDefaultContext2;
    exports.Dictionary = exports.UnknownRecord;
    var ObjectType = (
      /** @class */
      function(_super) {
        __extends(ObjectType2, _super);
        function ObjectType2() {
          var _this = _super.call(this, "object", function(u) {
            return u !== null && typeof u === "object";
          }, function(u, c) {
            return _this.is(u) ? (0, exports.success)(u) : (0, exports.failure)(u, c);
          }, exports.identity) || this;
          _this._tag = "ObjectType";
          return _this;
        }
        return ObjectType2;
      }(Type)
    );
    exports.ObjectType = ObjectType;
    exports.object = new ObjectType();
    exports.dictionary = record2;
    var StrictType = (
      /** @class */
      function(_super) {
        __extends(StrictType2, _super);
        function StrictType2(name, is, validate, encode, props) {
          var _this = _super.call(this, name, is, validate, encode) || this;
          _this.props = props;
          _this._tag = "StrictType";
          return _this;
        }
        return StrictType2;
      }(Type)
    );
    exports.StrictType = StrictType;
    function clean(codec) {
      return codec;
    }
    exports.clean = clean;
    function alias(codec) {
      return function() {
        return codec;
      };
    }
    exports.alias = alias;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FrontmatterSmithPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/FuzzySuggester.ts
var import_obsidian = require("obsidian");
var FuzzySuggester = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, items, getText, callback) {
    super(app);
    this.getText = getText;
    this.itemSelected = false;
    this.items = items;
    this.callback = callback;
  }
  getItems() {
    return this.items;
  }
  getItemText(item) {
    return this.getText(item);
  }
  onClose() {
    if (!this.itemSelected) {
      this.callback(null);
    }
  }
  selectSuggestion(value2, evt) {
    this.itemSelected = true;
    console.log("Selected");
    this.close();
    this.onChooseItem(value2.item, evt);
  }
  onChooseItem(item, evt) {
    this.callback(item);
  }
};

// src/ObsidianPromptModal.ts
var import_obsidian2 = require("obsidian");
var ObsidianPromptModal = class extends import_obsidian2.Modal {
  constructor(app, options, cb) {
    super(app);
    this.submitted = false;
    this.prompt = options.prompt;
    this.defaultValue = options.defaultValue;
    this.cb = cb;
  }
  onOpen() {
    this.titleEl.setText(this.prompt);
    this.titleEl.id = "frontmatter-forge-prompt-label";
    this.createForm();
  }
  onClose() {
    this.contentEl.empty();
    if (!this.submitted) {
      this.cb(null);
    }
  }
  createForm() {
    const form2 = this.contentEl.createDiv().createEl("form");
    form2.addEventListener("submit", (e) => {
      e.preventDefault();
      this.submitted = true;
      this.close();
      this.cb(this.value);
    });
    form2.addClass("templater-prompt-div");
    const textInput = new import_obsidian2.TextComponent(form2);
    textInput.inputEl.style.setProperty("width", "100%");
    textInput.inputEl.setAttribute(
      "aria-labelledby",
      "frontmatter-forge-prompt-label"
    );
    this.value = this.defaultValue || "";
    textInput.setPlaceholder("Type text here");
    textInput.setValue(this.value);
    textInput.onChange((value2) => this.value = value2);
    textInput.inputEl.focus();
  }
};

// src/modals.ts
var _app, _constructors;
var Modals = class {
  constructor(app, constructors) {
    __privateAdd(this, _app, void 0);
    __privateAdd(this, _constructors, void 0);
    __privateSet(this, _app, app);
    __privateSet(this, _constructors, constructors);
  }
  prompt(options) {
    return new Promise((resolve, reject) => {
      const suggester = new (__privateGet(this, _constructors)).ObsidianPromptModal(
        __privateGet(this, _app),
        options,
        resolve
      );
      suggester.open();
    });
  }
  suggest(items, placeholder) {
    return new Promise((resolve, reject) => {
      const suggester = new (__privateGet(this, _constructors)).FuzzySuggester(
        __privateGet(this, _app),
        items,
        (x) => x.text,
        (x) => resolve(x)
      );
      if (placeholder) {
        suggester.setPlaceholder(placeholder);
      }
      suggester.open();
    });
  }
};
_app = new WeakMap();
_constructors = new WeakMap();

// PluginSettings.ts
var import_obsidian3 = require("obsidian");

// node_modules/.pnpm/vanjs-core@1.5.1/node_modules/vanjs-core/src/van.js
var protoOf = Object.getPrototypeOf;
var changedStates;
var derivedStates;
var curDeps;
var curNewDerives;
var alwaysConnectedDom = { isConnected: 1 };
var gcCycleInMs = 1e3;
var statesToGc;
var propSetterCache = {};
var objProto = protoOf(alwaysConnectedDom);
var funcProto = protoOf(protoOf);
var _undefined;
var addAndScheduleOnFirst = (set, s, f, waitMs) => (set != null ? set : (setTimeout(f, waitMs), /* @__PURE__ */ new Set())).add(s);
var runAndCaptureDeps = (f, deps, arg) => {
  let prevDeps = curDeps;
  curDeps = deps;
  try {
    return f(arg);
  } catch (e) {
    console.error(e);
    return arg;
  } finally {
    curDeps = prevDeps;
  }
};
var keepConnected = (l) => l.filter((b) => {
  var _a;
  return (_a = b._dom) == null ? void 0 : _a.isConnected;
});
var addStatesToGc = (d) => statesToGc = addAndScheduleOnFirst(statesToGc, d, () => {
  for (let s of statesToGc)
    s._bindings = keepConnected(s._bindings), s._listeners = keepConnected(s._listeners);
  statesToGc = _undefined;
}, gcCycleInMs);
var stateProto = {
  get val() {
    var _a;
    (_a = curDeps == null ? void 0 : curDeps._getters) == null ? void 0 : _a.add(this);
    return this.rawVal;
  },
  get oldVal() {
    var _a;
    (_a = curDeps == null ? void 0 : curDeps._getters) == null ? void 0 : _a.add(this);
    return this._oldVal;
  },
  set val(v) {
    var _a;
    (_a = curDeps == null ? void 0 : curDeps._setters) == null ? void 0 : _a.add(this);
    if (v !== this.rawVal) {
      this.rawVal = v;
      this._bindings.length + this._listeners.length ? (derivedStates == null ? void 0 : derivedStates.add(this), changedStates = addAndScheduleOnFirst(changedStates, this, updateDoms)) : this._oldVal = v;
    }
  }
};
var state = (initVal) => ({
  __proto__: stateProto,
  rawVal: initVal,
  _oldVal: initVal,
  _bindings: [],
  _listeners: []
});
var bind = (f, dom) => {
  let deps = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, binding = { f }, prevNewDerives = curNewDerives;
  curNewDerives = [];
  let newDom = runAndCaptureDeps(f, deps, dom);
  newDom = (newDom != null ? newDom : document).nodeType ? newDom : new Text(newDom);
  for (let d of deps._getters)
    deps._setters.has(d) || (addStatesToGc(d), d._bindings.push(binding));
  for (let l of curNewDerives)
    l._dom = newDom;
  curNewDerives = prevNewDerives;
  return binding._dom = newDom;
};
var derive = (f, s = state(), dom) => {
  var _a;
  let deps = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, listener = { f, s };
  listener._dom = (_a = dom != null ? dom : curNewDerives == null ? void 0 : curNewDerives.push(listener)) != null ? _a : alwaysConnectedDom;
  s.val = runAndCaptureDeps(f, deps, s.rawVal);
  for (let d of deps._getters)
    deps._setters.has(d) || (addStatesToGc(d), d._listeners.push(listener));
  return s;
};
var add = (dom, ...children) => {
  for (let c of children.flat(Infinity)) {
    let protoOfC = protoOf(c != null ? c : 0);
    let child = protoOfC === stateProto ? bind(() => c.val) : protoOfC === funcProto ? bind(c) : c;
    child != _undefined && dom.append(child);
  }
  return dom;
};
var tag = (ns, name, ...args) => {
  var _a, _b, _c, _d;
  let [props, ...children] = protoOf((_a = args[0]) != null ? _a : 0) === objProto ? args : [{}, ...args];
  let dom = ns ? document.createElementNS(ns, name) : document.createElement(name);
  for (let [k, v] of Object.entries(props)) {
    let getPropDescriptor = (proto) => {
      var _a2;
      return proto ? (_a2 = Object.getOwnPropertyDescriptor(proto, k)) != null ? _a2 : getPropDescriptor(protoOf(proto)) : _undefined;
    };
    let cacheKey = name + "," + k;
    let propSetter = (_d = propSetterCache[cacheKey]) != null ? _d : propSetterCache[cacheKey] = (_c = (_b = getPropDescriptor(protoOf(dom))) == null ? void 0 : _b.set) != null ? _c : 0;
    let setter = k.startsWith("on") ? (v2, oldV) => {
      let event = k.slice(2);
      dom.removeEventListener(event, oldV);
      dom.addEventListener(event, v2);
    } : propSetter ? propSetter.bind(dom) : dom.setAttribute.bind(dom, k);
    let protoOfV = protoOf(v != null ? v : 0);
    k.startsWith("on") || protoOfV === funcProto && (v = derive(v), protoOfV = stateProto);
    protoOfV === stateProto ? bind(() => (setter(v.val, v._oldVal), dom)) : setter(v);
  }
  return add(dom, children);
};
var handler = (ns) => ({ get: (_, name) => tag.bind(_undefined, ns, name) });
var update = (dom, newDom) => newDom ? newDom !== dom && dom.replaceWith(newDom) : dom.remove();
var updateDoms = () => {
  let iter = 0, derivedStatesArray = [...changedStates].filter((s) => s.rawVal !== s._oldVal);
  do {
    derivedStates = /* @__PURE__ */ new Set();
    for (let l of new Set(derivedStatesArray.flatMap((s) => s._listeners = keepConnected(s._listeners))))
      derive(l.f, l.s, l._dom), l._dom = _undefined;
  } while (++iter < 100 && (derivedStatesArray = [...derivedStates]).length);
  let changedStatesArray = [...changedStates].filter((s) => s.rawVal !== s._oldVal);
  changedStates = _undefined;
  for (let b of new Set(changedStatesArray.flatMap((s) => s._bindings = keepConnected(s._bindings))))
    update(b._dom, bind(b.f, b._dom)), b._dom = _undefined;
  for (let s of changedStatesArray)
    s._oldVal = s.rawVal;
};
var van_default = {
  tags: new Proxy((ns) => new Proxy(tag, handler(ns)), handler()),
  hydrate: (dom, f) => update(dom, bind(f, dom)),
  add,
  state,
  derive
};

// src/configuration-editor/index.module.css
var forgeConfig = "frontmatter-smith-79MhFW-forge-config";

// src/configuration-editor/obsidian-controls.ts
var { div } = van_default.tags;
var SettingItem = (...children) => div({ className: "setting-item" }, children);
var SettingItemInfo = (...children) => div({ className: "setting-item-info" }, children);
var SettingItemControl = (...children) => div({ className: "setting-item-control" }, children);
var SettingItemName = (...children) => div({ className: "setting-item-name" }, children);
var SettingItemDescription = (...children) => div({ className: "setting-item-description" }, children);
var Setting = (props) => {
  const { control, renderControl } = props;
  if (control && renderControl) {
    throw new Error("Cannot have both 'control' and 'renderControl' props");
  }
  return SettingItem(
    SettingItemInfo(
      SettingItemName(props.name),
      props.description && SettingItemDescription(props.description)
    ),
    props.control && SettingItemControl(props.control)
  );
};

// src/configuration-editor/forge-editor/index.module.css
var forgeConfigBlock = "frontmatter-smith-MG0XdW-forge-config-block";
var forgeConfigCommands = "frontmatter-smith-MG0XdW-forge-config-commands";
var forgeConfigHeader = "frontmatter-smith-MG0XdW-forge-config-header";
var forgeConfigHeading = "frontmatter-smith-MG0XdW-forge-config-heading";
var hidden = "frontmatter-smith-MG0XdW-hidden";

// src/configuration-editor/helpers.ts
var genId = (() => {
  let __nextId = 1;
  return (pattern) => `${pattern ? pattern + "-" : ""}${(++__nextId).toString()}`;
})();
var stateArray = (a) => {
  const result = van_default.state(a.val.map((x) => van_default.state(x)));
  van_default.derive(() => {
    const resultVal = result.val;
    if (resultVal !== result.oldVal || resultVal.find((x) => x.val !== x.oldVal)) {
      a.val = result.val.map((x) => x.val);
    }
  });
  return result;
};
var deepState = (x) => {
  const entries = Object.entries(x.val);
  const stateEntries = entries.map(([key, val]) => [key, van_default.state(val)]);
  const result = Object.fromEntries(stateEntries);
  van_default.derive(() => {
    const data = stateEntries.map(([key, state2]) => {
      const val = state2.val;
      return [
        key,
        val,
        val !== state2.oldVal
        /* was this value changed */
      ];
    });
    const changed = data.find((x2) => x2[2]);
    if (changed) {
      x.val = Object.fromEntries(data);
    }
  });
  return result;
};
var wrapState = (val, state2) => {
  const result = van_default.state(val);
  van_default.derive(() => {
    const val2 = result.val;
    if (val2 !== result.oldVal) {
      state2.val = val2;
    }
  });
  return result;
};
var deepState2way = (x) => {
  const entries = Object.entries(x.val);
  const stateEntries = entries.map(([key, val]) => [key, van_default.state(val)]);
  const result = Object.fromEntries(stateEntries);
  van_default.derive(() => {
    const newParent = x.val;
    if (newParent !== x.oldVal) {
      for (const entry of Object.entries(x.val)) {
        const [key, val] = entry;
        result[key].val = val;
      }
    }
  });
  van_default.derive(() => {
    const data = stateEntries.map(([key, state2]) => {
      const val = state2.val;
      return [
        key,
        val,
        val !== state2.oldVal
        /* was this value changed */
      ];
    });
    const changed = data.find((x2) => x2[2]);
    if (changed) {
      x.val = Object.fromEntries(data);
    }
  });
  return result;
};

// src/configuration-editor/value-editor/index.module.css
var errorMsg = "frontmatter-smith-h3klXG-error-msg";
var newCommandForm = "frontmatter-smith-h3klXG-new-command-form";

// src/configuration-editor/value-editor/choice-value-editor.module.css
var choiceCommands = "frontmatter-smith-3ttuBa-choice-commands";
var choiceSection = "frontmatter-smith-3ttuBa-choice-section";
var hidden2 = "frontmatter-smith-3ttuBa-hidden";
var optionsList = "frontmatter-smith-3ttuBa-options-list";
var valueTypeDescription = "frontmatter-smith-3ttuBa-value-type-description";
var valueTypeHeading = "frontmatter-smith-3ttuBa-value-type-heading";

// src/configuration-editor/containers/index.module.css
var commandBlock = "frontmatter-smith-I0bVoa-command-block";
var commandBlockLeft = "frontmatter-smith-I0bVoa-command-block-left";
var commandDescription = "frontmatter-smith-I0bVoa-command-description";
var commandHeading = "frontmatter-smith-I0bVoa-command-heading";
var valueList = "frontmatter-smith-I0bVoa-value-list";

// src/configuration-editor/tags.ts
var h1 = van_default.tags.h1;
var h2 = van_default.tags.h2;
var h3 = van_default.tags.h3;
var h4 = van_default.tags.h4;
var h5 = van_default.tags.h5;
var h6 = van_default.tags.h6;
var p = van_default.tags.p;
var div2 = van_default.tags.div;
var section = van_default.tags.section;
var form = van_default.tags.form;
var label = van_default.tags.label;
var input = van_default.tags.input;
var button = van_default.tags.button;
var select = van_default.tags.select;
var option = van_default.tags.option;

// src/configuration-editor/containers/index.ts
var { div: div3 } = van_default.tags;
var ChildGroup = (...rest) => div3({ className: valueList }, ...rest);
var HeadingWithButton = (props) => {
  const { name, description, control } = props;
  return div3(
    { className: commandBlock },
    div3(
      { className: commandBlockLeft },
      h4(
        {
          className: commandHeading
        },
        name
      ),
      p({ className: commandDescription }, description)
    ),
    control
  );
};

// src/configuration-editor/components.ts
var ExpandCollapseButton = (props) => {
  const { visible, type: type3, controlledContainerId } = props;
  const expandCollapseLabel = van_default.derive(
    () => visible.val ? `Collapse ${type3}` : `Expand ${type3}`
  );
  const expendButtonContent = van_default.derive(() => visible.val ? "\u25BC" : "\u25B2");
  return button(
    {
      className: "clickable-icon",
      "aria-label": expandCollapseLabel,
      "aria-expanded": visible,
      "aria-controls": controlledContainerId,
      onclick: (e) => {
        e.stopPropagation();
        visible.val = !visible.val;
      }
    },
    expendButtonContent
  );
};
var SimpleStateInput = ({ labelId, value: value2 }) => input({
  type: "text",
  "aria-labelledBy": labelId,
  value: value2.val,
  oninput: (e) => {
    value2.val = e.target.value;
  }
});
var StateInput = (props) => input({
  ...props,
  value: props.value.val,
  oninput: (e) => {
    props.value.val = e.target.value;
  }
});

// src/smith-configuration-schema.ts
var t3 = __toESM(require_lib());

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/es6/function.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function identity(a) {
  return a;
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      var ret = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var dual = function(arity, body) {
  var isDataFirst = typeof arity === "number" ? function(args) {
    return args.length >= arity;
  } : arity;
  return function() {
    var args = Array.from(arguments);
    if (isDataFirst(arguments)) {
      return body.apply(this, args);
    }
    return function(self) {
      return body.apply(void 0, __spreadArray([self], args, false));
    };
  };
};

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/es6/internal.js
var isLeft = function(ma) {
  return ma._tag === "Left";
};
var right = function(a) {
  return { _tag: "Right", right: a };
};

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/es6/Chain.js
function tap(M) {
  return function(first, f) {
    return M.chain(first, function(a) {
      return M.map(f(a), function() {
        return a;
      });
    });
  };
}

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/es6/Functor.js
function as(F) {
  return function(self, b) {
    return F.map(self, function() {
      return b;
    });
  };
}
function asUnit(F) {
  var asM = as(F);
  return function(self) {
    return asM(self, void 0);
  };
}

// node_modules/.pnpm/fp-ts@2.16.8/node_modules/fp-ts/es6/Either.js
var right2 = right;
var flatMap = /* @__PURE__ */ dual(2, function(ma, f) {
  return isLeft2(ma) ? ma : f(ma.right);
});
var _map = function(fa, f) {
  return pipe(fa, map(f));
};
var _ap = function(fab, fa) {
  return pipe(fab, ap(fa));
};
var URI = "Either";
var map = function(f) {
  return function(fa) {
    return isLeft2(fa) ? fa : right2(f(fa.right));
  };
};
var Functor = {
  URI,
  map: _map
};
var as2 = dual(2, as(Functor));
var asUnit2 = asUnit(Functor);
var apW = function(fa) {
  return function(fab) {
    return isLeft2(fab) ? fab : isLeft2(fa) ? fa : right2(fab.right(fa.right));
  };
};
var ap = apW;
var Chain = {
  URI,
  map: _map,
  ap: _ap,
  chain: flatMap
};
var FromEither = {
  URI,
  fromEither: identity
};
var isLeft2 = isLeft;
var tap2 = /* @__PURE__ */ dual(2, tap(Chain));
var _FromEither = {
  fromEither: FromEither.fromEither
};
var orElseW = function(onLeft) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : ma;
  };
};
var orElse = orElseW;

// node_modules/.pnpm/io-ts-types@0.5.19_fp-ts@2.16.8_io-ts@2.2.21_fp-ts@2.16.8__monocle-ts@2.3.13_fp-ts@2.16.8__ne_o5rqgajkox4nbust2i7btfcqq4/node_modules/io-ts-types/es6/clone.js
function clone(t5) {
  var r = Object.create(Object.getPrototypeOf(t5));
  Object.assign(r, t5);
  return r;
}

// node_modules/.pnpm/io-ts-types@0.5.19_fp-ts@2.16.8_io-ts@2.2.21_fp-ts@2.16.8__monocle-ts@2.3.13_fp-ts@2.16.8__ne_o5rqgajkox4nbust2i7btfcqq4/node_modules/io-ts-types/es6/withFallback.js
var t2 = __toESM(require_lib());

// node_modules/.pnpm/io-ts-types@0.5.19_fp-ts@2.16.8_io-ts@2.2.21_fp-ts@2.16.8__monocle-ts@2.3.13_fp-ts@2.16.8__ne_o5rqgajkox4nbust2i7btfcqq4/node_modules/io-ts-types/es6/withValidate.js
var t = __toESM(require_lib());
function withValidate(codec, validate, name) {
  if (name === void 0) {
    name = codec.name;
  }
  var r = clone(codec);
  r.validate = validate;
  r.decode = function(i) {
    return validate(i, t.getDefaultContext(r));
  };
  r.name = name;
  return r;
}

// node_modules/.pnpm/io-ts-types@0.5.19_fp-ts@2.16.8_io-ts@2.2.21_fp-ts@2.16.8__monocle-ts@2.3.13_fp-ts@2.16.8__ne_o5rqgajkox4nbust2i7btfcqq4/node_modules/io-ts-types/es6/withFallback.js
function withFallback(codec, a, name) {
  if (name === void 0) {
    name = "withFallback(" + codec.name + ")";
  }
  return withValidate(codec, function(u, c) {
    return orElse(function() {
      return t2.success(a);
    })(codec.validate(u, c));
  }, name);
}

// src/smith-configuration-schema.ts
var import_Either2 = __toESM(require_Either());

// node_modules/.pnpm/nanoid@5.0.7/node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/.pnpm/nanoid@5.0.7/node_modules/nanoid/index.browser.js
var nanoid = (size = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size));
  while (size--) {
    id += urlAlphabet[bytes[size] & 63];
  }
  return id;
};

// src/smith-configuration-schema.ts
var withFallbackFn = (codec, a, name = `withFallback(${codec.name})`) => {
  return withValidate(
    codec,
    (u, c) => (0, import_Either2.orElse)(() => t3.success(a()))(codec.validate(u, c)),
    name
  );
};
var createId = nanoid;
var $id = withFallbackFn(t3.string, createId);
var value = t3.recursion("Value", () => {
  const stringInput = t3.strict({
    $type: t3.union([t3.literal("string-input"), t3.literal("number-input")]),
    prompt: t3.string
  });
  const constantValue = t3.strict({
    $type: t3.literal("constant"),
    value: t3.any
  });
  const choiceValueItem = t3.type({
    $id,
    text: t3.string,
    value: t3.string,
    commands: withFallback(t3.array(command), [])
  });
  const choiceValue = t3.type({
    $type: t3.literal("choice-input"),
    prompt: t3.string,
    options: t3.array(choiceValueItem)
  });
  const objectValueItem = t3.type({
    $id,
    key: t3.string,
    value
  });
  const objectValue = t3.type({
    $type: t3.literal("object"),
    values: t3.array(objectValueItem)
  });
  return t3.union([objectValue, stringInput, choiceValue, constantValue]);
});
var command = t3.recursion("Command", () => {
  const addToArrayCommand = t3.strict({
    $id,
    $command: t3.literal("add-array-element"),
    key: t3.string,
    value
  });
  const setValueCommand = t3.strict({
    $id,
    $command: t3.literal("set-value"),
    key: t3.string,
    value
  });
  return t3.union([addToArrayCommand, setValueCommand]);
});
var forgeConfiguration = t3.strict({
  $id,
  name: t3.string,
  commands: t3.array(command)
});
var smithConfiguration = t3.strict({
  version: t3.literal("1"),
  forges: t3.array(forgeConfiguration)
});
var emptySmithConfiguration = {
  version: "1",
  forges: []
};

// src/configuration-editor/defaults.ts
var createDefaultObjectValueItem = () => ({
  $id: createId(),
  key: "key ...",
  value: createDefaultValue()
});
var createDefaultChoiceValueItem = () => ({
  $id: createId(),
  text: "Value ...",
  value: "Value ...",
  commands: []
});
var createDefaultForgeConfiguration = () => ({
  $id: createId(),
  name: "Forge name ...",
  commands: [createDefaultSetValueCommand()]
});
var createDefaultConstantValue = () => ({
  $type: "constant",
  value: "value"
});
var createDefaultChoiceValue = () => ({
  $type: "choice-input",
  prompt: "Choice ...",
  options: []
});
var createDefaultStringInputValue = () => ({
  $type: "string-input",
  prompt: "choice ..."
});
var createDefaultNumberInputValue = () => ({
  $type: "number-input",
  prompt: "choice ..."
});
var createDefaultObjectValue = () => ({
  $type: "object",
  values: []
});
var createDefaultValue = () => createDefaultConstantValue();
var createAddToArrayCommand = () => ({
  $id: createId(),
  $command: "add-array-element",
  key: "Key",
  value: createDefaultValue()
});
var createDefaultSetValueCommand = () => ({
  $id: createId(),
  $command: "set-value",
  key: "Key",
  value: createDefaultValue()
});
var createDefaultCommandByType = (type3) => {
  switch (type3) {
    case "add-array-element":
      return createAddToArrayCommand();
    case "set-value":
      return createDefaultSetValueCommand();
  }
};

// src/configuration-editor/value-editor/choice-value-editor.ts
var { section: section2, label: label2, div: div4, h4: h42, p: p2, button: button2 } = van_default.tags;
var Choice = (props) => {
  const { choice, textLabelId, valueLabelId } = props;
  const showChildren = van_default.state(false);
  const childCls = van_default.derive(
    () => showChildren.val ? choiceCommands : choiceCommands + " " + hidden2
  );
  const { commands, text, value: value2 } = deepState(choice);
  const optionContainerId = genId("option-container");
  const element = section2(
    {
      "aria-label": "Option: " + choice.val.value,
      className: choiceSection
    },
    ExpandCollapseButton({
      visible: showChildren,
      type: "choice",
      controlledContainerId: optionContainerId
    }),
    SimpleStateInput({ labelId: textLabelId, value: text }),
    SimpleStateInput({ labelId: valueLabelId, value: value2 }),
    div4(
      button2(
        { onclick: () => props.onRemoveClick({ element, choice }) },
        "Remove choice"
      )
    ),
    div4(
      { id: optionContainerId, className: childCls },
      h42("Commands"),
      p2(
        { className: "text-muted" },
        "Add additional commands that are executed if this choice is selected"
      ),
      CommandList({ commands })
    )
  );
  return element;
};
var ChoiceInputConfiguration = (props) => {
  const headingId = genId("choice-heading");
  const { prompt } = deepState(props.value);
  return section2(
    { "aria-labelledBy": headingId },
    h42({ id: headingId, className: valueTypeHeading }, "Choice:"),
    div4(
      { className: valueTypeDescription },
      "Provides a selection of multiple choices. Each choice can contain subsequent commands to run if that choice is selected."
    ),
    Setting({
      name: "Prompt",
      description: "The heading of the prompt dialog",
      control: StateInput({
        type: "text",
        ["aria-label"]: "Prompt",
        value: prompt
      })
    }),
    Choices(props)
  );
};
var Choices = (props) => {
  const ds = deepState(props.value);
  const options = stateArray(ds.options);
  const onRemoveClick = ({ element, choice }) => {
    options.val = options.val.filter((x) => x !== choice);
    optionsDiv.removeChild(element);
  };
  const textLabelId = genId("option-text-label");
  const valueLabelId = genId("option-value-label");
  const optionsDiv = div4(
    {
      className: optionsList
    },
    div4(),
    label2({ id: textLabelId }, "Text"),
    label2({ id: valueLabelId }, "Value"),
    div4(),
    options.val.map((choice, i) => {
      return Choice({ choice, onRemoveClick, textLabelId, valueLabelId });
    })
  );
  return [
    HeadingWithButton({
      name: "Choices",
      description: "",
      control: button2(
        {
          onclick: (e) => {
            const choice = van_default.state(createDefaultChoiceValueItem());
            options.val = [...options.val, choice];
            van_default.add(
              optionsDiv,
              Choice({ choice, onRemoveClick, textLabelId, valueLabelId })
            );
          }
        },
        "Add choice"
      )
    }),
    ChildGroup(optionsDiv)
  ];
};

// src/configuration-editor/value-editor/object-value-editor.module.css
var property = "frontmatter-smith-HTuMoW-property";
var propertyList = "frontmatter-smith-HTuMoW-property-list";
var propertyValue = "frontmatter-smith-HTuMoW-property-value";

// src/configuration-editor/value-editor/object-value-editor.ts
var ValueEditor = (props) => {
  const { onRemoveClick, keyLabelId } = props;
  const { key, value: value2 } = deepState(props.value);
  const visible = van_default.state(false);
  const style = van_default.derive(
    () => visible.val ? "display: block" : "display: none"
  );
  const valueContainerId = genId("value-container");
  const element = section(
    { "aria-labelledBy": keyLabelId, className: property },
    ExpandCollapseButton({
      visible,
      type: "value editor",
      controlledContainerId: valueContainerId
    }),
    input({
      type: "text",
      value: key.val,
      "aria-label": "Key",
      oninput: (e) => {
        key.val = e.target.value;
      }
    }),
    ValueTypeEditor({ value: value2 }),
    button(
      {
        onclick: () => {
          onRemoveClick({ element, value: props.value });
        }
      },
      "Remove"
    ),
    renderValueEditor(
      div2({ id: valueContainerId, className: propertyValue, style }),
      value2
    )
  );
  return element;
};
var ObjectValueEditor = ({ value: value2 }) => {
  const values = stateArray(deepState(value2).values);
  const onRemoveClick = ({ element, value: value3 }) => {
    values.val = values.val.filter((x) => x !== value3);
    items.removeChild(element);
  };
  const keyLabelId = genId("attribute-label");
  const items = div2(
    { className: propertyList },
    div2(),
    label({ id: keyLabelId }, "Object key"),
    div2("Value"),
    div2(),
    values.val.map(
      (value3) => ValueEditor({ value: value3, onRemoveClick, keyLabelId })
    )
  );
  return section(
    HeadingWithButton({
      name: "Object value",
      description: "",
      control: button(
        {
          onclick: () => {
            const value3 = van_default.state(createDefaultObjectValueItem());
            values.val = [...values.val, value3];
            van_default.add(items, ValueEditor({ value: value3, keyLabelId, onRemoveClick }));
          }
        },
        "Add value"
      )
    }),
    items
  );
};

// src/configuration-editor/command-editor/index.module.css
var commandBlock2 = "frontmatter-smith-jZeyoW-command-block";
var commandBlockLeft2 = "frontmatter-smith-jZeyoW-command-block-left";
var commandDescription2 = "frontmatter-smith-jZeyoW-command-description";
var commandHeading2 = "frontmatter-smith-jZeyoW-command-heading";

// src/configuration-editor/command-editor/index.ts
var CommandNameAndDesc = (props) => {
  const { headingId, name, description, onRemoveClick } = props;
  return div2(
    { className: commandBlock2 },
    div2(
      { className: commandBlockLeft2 },
      h4(
        {
          id: headingId,
          className: commandHeading2,
          "aria-label": `Command: ${name}`
        },
        name
      ),
      p({ className: commandDescription2 }, description)
    ),
    button(
      {
        onclick: () => {
          onRemoveClick();
        }
      },
      "Remove command"
    )
  );
};
var SetValueEditor = (props) => {
  const { command: command2, headingId } = props;
  const { key, value: value2 } = deepState(command2);
  return [
    CommandNameAndDesc({
      name: "Set Value",
      description: "Sets a single property in the frontmatter",
      headingId,
      onRemoveClick: props.onRemoveClick
    }),
    Setting({
      name: "Key",
      description: "This is the name of the frontmatter field that will be set",
      control: StateInput({ type: "text", value: key, ["aria-label"]: "Key" })
    }),
    Setting({
      name: "Value",
      description: "How will the value be generated",
      control: ValueTypeEditor({ value: value2 })
    }),
    renderValueEditor(ChildGroup(), value2)
  ];
};
var AddArrayElementEditor = (props) => {
  const { headingId, onRemoveClick, command: command2 } = props;
  const { value: value2, key } = deepState(command2);
  return [
    CommandNameAndDesc({
      headingId,
      name: "Add element to array",
      description: "Assumes the element is an array. The generated value will be added to the array.",
      onRemoveClick
    }),
    Setting({
      name: "Key",
      description: "This is the name of the frontmatter field that will be created",
      control: StateInput({ type: "text", value: key, ["aria-label"]: "Key" })
    }),
    //ValueConfiguration({ value }),
    Setting({
      name: "Value",
      description: "How will the value be generated",
      control: ValueTypeEditor({ value: value2 })
    }),
    renderValueEditor(ChildGroup(), value2)
  ];
};
var UnknownCommandEditor = (props) => div2(
  "The configuration contains an unrecognised element, and you will not be able to edit it"
);
var renderEditor = (command2, headingId, onRemoveClick) => {
  const tmp = command2.val;
  switch (tmp.$command) {
    case "set-value": {
      const result = wrapState(tmp, command2);
      return SetValueEditor({ command: result, headingId, onRemoveClick });
    }
    case "add-array-element": {
      const result = wrapState(tmp, command2);
      return AddArrayElementEditor({
        command: result,
        headingId,
        onRemoveClick
      });
    }
    default:
      return UnknownCommandEditor({ command: tmp });
  }
};
var CommandEditor = (props) => {
  const { command: command2 } = props;
  const id = genId("command-section");
  const element = section(
    { "aria-labelledBy": id },
    renderEditor(command2, id, () => {
      props.onRemoveCommandClick({ element, command: command2 });
    })
  );
  return element;
};

// src/configuration-editor/value-editor/index.ts
var Option = ({
  type: type3,
  text,
  selectedValue
}) => option({ value: type3, selected: type3 === selectedValue }, text);
var optionDescriptors = [
  {
    type: "choice-input",
    text: "Choice input"
  },
  {
    type: "object",
    text: "An object value"
  },
  {
    type: "constant",
    text: "A constant value"
  },
  {
    type: "string-input",
    text: "A text value"
  },
  {
    type: "number-input",
    text: "A numeric value"
  }
];
var ConstValueConfiguration = (props) => {
  const id = genId("input-error");
  const valid = van_default.state(true);
  const touched = van_default.state(false);
  const showError = van_default.derive(() => touched.val && !valid.val);
  const i = input({
    "aria-label": "Value",
    "aria-errormessage": id,
    "aria-invalid": van_default.derive(() => showError.val ? "true" : "false"),
    type: "text",
    onblur: () => {
      touched.val = true;
    },
    oninput: (e) => {
      try {
        props.value.val = {
          ...props.value.val,
          value: JSON.parse(e.target.value)
        };
        valid.val = true;
      } catch (e2) {
        valid.val = false;
      }
    }
  });
  const err = p(
    {
      id,
      style: van_default.derive(
        () => showError.val ? "display: block" : "display: none"
      ),
      className: errorMsg
    },
    "Invalid JSON"
  );
  return div2(
    Setting({
      name: "Constant",
      description: `The constant 'value', must be valid JSON format. This allows the value to be simple text values, or complex objects or arrays. For a text value, the correct format is to enclose the value in quotation marks ( " )`,
      control: div2(i, err)
    })
  );
};
var ValueConfigurationInner = (props) => {
  const tmp = props.value.val;
  switch (tmp.$type) {
    case "constant": {
      const value2 = wrapState(tmp, props.value);
      return ConstValueConfiguration({ value: value2 });
    }
    case "string-input":
    case "number-input": {
      const value2 = wrapState(tmp, props.value);
      return StringInputConfiguration({ value: value2 });
    }
    case "choice-input": {
      const value2 = wrapState(tmp, props.value);
      return ChoiceInputConfiguration({ value: value2 });
    }
    case "object": {
      const value2 = wrapState(tmp, props.value);
      return ObjectValueEditor({ value: value2 });
    }
    default:
      return UnrecognisedValue({ value: tmp });
  }
};
var ValueTypeEditor = (props) => select(
  {
    className: "dropdown",
    "aria-label": "Type of value",
    onchange: (e) => {
      switch (e.target.value) {
        case "constant":
          props.value.val = createDefaultChoiceValue();
          break;
        case "string-input":
          props.value.val = createDefaultStringInputValue();
          break;
        case "number-input":
          props.value.val = createDefaultNumberInputValue();
          break;
        case "object":
          props.value.val = createDefaultObjectValue();
          break;
        case "choice-input":
          props.value.val = createDefaultChoiceValue();
          break;
      }
    }
  },
  optionDescriptors.map(
    (option2) => Option({ ...option2, selectedValue: props.value.val.$type })
  )
);
var StringInputConfiguration = (props) => {
  const { prompt } = deepState(props.value);
  return Setting({
    name: "Prompt",
    description: "This will be displayed in the prompt of the dialog",
    control: input({
      type: "text",
      value: props.value.val.prompt,
      "aria-label": "Prompt",
      oninput: (e) => {
        prompt.val = e.target.value;
      }
    })
  });
};
var UnrecognisedValue = (props) => div2(
  "Your configuration contains an unrecognised value, and you will not be able to edit it"
);
var CommandList = (props) => {
  const states = stateArray(props.commands);
  const onRemoveCommandClick = ({ element, command: command2 }) => {
    states.val = states.val.filter((x) => x !== command2);
    children.removeChild(element);
  };
  const children = ChildGroup(
    states.val.map(
      (command2, i) => CommandEditor({ command: command2, onRemoveCommandClick })
    )
  );
  const dropdown = select(
    { className: "dropdown" },
    option({ value: "add-array-element" }, "Add to array"),
    option({ value: "set-value" }, "Set value")
  );
  return [
    Setting({
      name: "Commands",
      description: "Enter the commands to run for this command",
      control: form(
        { className: newCommandForm },
        dropdown,
        button(
          {
            onclick: (e) => {
              e.preventDefault();
              const command2 = van_default.state(
                createDefaultCommandByType(dropdown.value)
              );
              states.val = [...states.val, command2];
              van_default.add(
                children,
                CommandEditor({ command: command2, onRemoveCommandClick })
              );
            }
          },
          "Add command"
        )
      )
    }),
    children
  ];
};
var renderValueEditor = (parent, value2) => {
  const type3 = van_default.derive(() => value2.val.$type);
  let editor = ValueConfigurationInner({ value: value2 });
  van_default.add(parent, editor);
  van_default.derive(() => {
    if (type3.val !== type3.oldVal) {
      parent.removeChild(editor);
      editor = ValueConfigurationInner({ value: value2 });
      van_default.add(parent, editor);
    }
  });
  return parent;
};

// src/configuration-editor/forge-editor/index.ts
var clsx = (...args) => {
  return args.reduce((p3, c) => typeof c === "string" ? p3 + " " + c : p3, "").trim();
};
var { section: section3, h3: h32, input: input2 } = van_default.tags;
function ForgeEditor(props) {
  const { forgeConfig: forgeConfig2, expand, editorConfiguration: editorConfiguration2 } = props;
  const { expanded } = deepState2way(editorConfiguration2);
  const id = genId("forge-config-heading");
  const $id2 = forgeConfig2.val.$id;
  const { name, commands } = deepState(forgeConfig2);
  const defaultVisible = expand || editorConfiguration2.val.expanded[$id2] || false;
  const visible = van_default.state(defaultVisible);
  const forgeContainerId = genId("forge-container");
  van_default.derive(() => {
    const newVal = visible.val;
    if (newVal != visible.oldVal) {
      expanded.val = { ...expanded.val, [$id2]: newVal };
    }
  });
  const elm = section3(
    {
      className: forgeConfigBlock,
      ["aria-labelledBy"]: id
    },
    div2(
      {
        className: forgeConfigHeader,
        onclick: () => {
          visible.val = !visible.val;
        }
      },
      ExpandCollapseButton({
        visible,
        type: "Forge",
        controlledContainerId: forgeContainerId
      }),
      h32(
        {
          id,
          className: forgeConfigHeading,
          ["aria-label"]: `Forge: ${name.val}`
        },
        name
      ),
      button(
        {
          onclick: (e) => {
            e.stopPropagation();
            props.onRemoveClick(elm, props.forgeConfig);
          },
          ["aria-label"]: "Remove forge"
        },
        "Remove"
      )
    ),
    div2(
      {
        id: forgeContainerId,
        className: () => clsx(
          forgeConfigCommands,
          !visible.val && hidden
        )
      },
      Setting({
        name: "Forge name",
        control: input2({
          type: "text",
          value: name.val,
          "aria-label": "Forge name",
          oninput: (e) => {
            name.val = e.target.value;
          }
        })
      }),
      CommandList({ commands })
    )
  );
  return elm;
}

// src/configuration-editor/index.ts
var { div: div5, button: button3 } = van_default.tags;
var ConfigurationEditor = (props) => {
  const s = van_default.state(props.config);
  const { editorConfiguration: editorConfiguration2, smithConfiguration: smithConfiguration2 } = deepState(s);
  const forges = stateArray(deepState(smithConfiguration2).forges);
  van_default.derive(() => {
    const newState = s.val;
    if (newState !== s.oldVal && props.onConfigChanged) {
      props.onConfigChanged(newState);
    }
  });
  const onRemoveClick = (elm, forge) => {
    result.removeChild(elm);
    forges.val = forges.val.filter((x) => x !== forge);
    const expanded = { ...editorConfiguration2.val.expanded };
    delete expanded[forge.val.$id];
    editorConfiguration2.val = { ...editorConfiguration2.val, expanded };
  };
  const result = div5(
    { className: forgeConfig },
    Setting({
      name: "Forges",
      description: 'A "forge" is a set of rules for populating frontmatter. A forge can generate multiple fields, and the fields generated can depend on previous choices',
      control: button3(
        {
          onclick: (e) => {
            e.preventDefault();
            const forgeConfig2 = van_default.state(createDefaultForgeConfiguration());
            forges.val = [...forges.val, forgeConfig2];
            van_default.add(
              result,
              ForgeEditor({
                forgeConfig: forgeConfig2,
                expand: true,
                editorConfiguration: editorConfiguration2,
                onRemoveClick
              })
            );
          }
        },
        "New forge"
      )
    }),
    ...forges.val.map(
      (forgeConfig2) => ForgeEditor({ forgeConfig: forgeConfig2, editorConfiguration: editorConfiguration2, onRemoveClick })
    )
  );
  return result;
};
var render = (root, config, onConfigChanged) => {
  van_default.add(root, ConfigurationEditor({ config, onConfigChanged }));
};

// PluginSettings.ts
var FrontmatterSmithSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin, onChange) {
    super(app, plugin);
    this.onChange = onChange;
  }
  setValue(value2) {
    this.value = value2;
  }
  hide() {
    const { containerEl } = this;
    while (containerEl.firstChild) {
      containerEl.removeChild(containerEl.firstChild);
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.setCssStyles({
      display: "flex",
      flexDirection: "column"
    });
    containerEl.createEl("h1", { text: "Frontmatter Smith" });
    const p3 = containerEl.createEl("p", {
      text: "This plugin is in its very early stages. For more information about hot to configure, "
    });
    p3.createEl("a", {
      text: "Check the readme file for plugin",
      href: "https://github.com/stroiman/obsidian-frontmatter-smith"
    });
    const newEditor = containerEl.createDiv();
    render(newEditor, this.value, (config) => this.onChange(config));
  }
};

// src/plugin-configuration.ts
var t4 = __toESM(require_lib());
var editorConfiguration = t4.type({
  expanded: t4.record(t4.string, t4.boolean)
});
var pluginConfiguration = t4.type({
  version: t4.literal("1"),
  type: t4.literal("plugin-config"),
  smithConfiguration,
  editorConfiguration: withFallback(editorConfiguration, { expanded: {} })
});
var possibleRootConfig = t4.union([pluginConfiguration, smithConfiguration]);
var defaultConfiguration = {
  version: "1",
  type: "plugin-config",
  editorConfiguration: { expanded: {} },
  smithConfiguration: emptySmithConfiguration
};
var createPluginConfigFromSmithConfig = (smithConfiguration2) => ({
  ...defaultConfiguration,
  smithConfiguration: smithConfiguration2
});
var parseConfiguration = (input3) => {
  const result = possibleRootConfig.decode(input3);
  switch (result._tag) {
    case "Left":
      return null;
    case "Right": {
      const config = result.right;
      return "forges" in config ? createPluginConfigFromSmithConfig(config) : config;
    }
  }
  throw new Error("Should not have arrived here");
};
var parseConfigurationOrDefault = (input3) => {
  return parseConfiguration(input3) || defaultConfiguration;
};

// src/Forge.ts
var import_function3 = __toESM(require_function());

// src/ForgeConfiguration.ts
var import_function2 = __toESM(require_function());
var andThen = (fn) => async (x) => {
  const prev = await x;
  const { value: value2, commands } = await fn(prev.value);
  return { value: value2, commands: [prev.commands, commands].flat() };
};
var map2 = (fn) => async (x) => {
  const prev = await x;
  return { value: await fn(prev.value), commands: prev.commands };
};
var addCommands = (commands) => (x) => (0, import_function2.pipe)(
  x,
  andThen((value2) => ({ value: value2, commands }))
);
var resolveResult = {
  ret: (value2) => Promise.resolve({ value: value2, commands: [] })
};
var NumberResolver = class {
  constructor(options) {
    this.options = options;
  }
  async run(deps) {
    const valueString = await deps.prompt(this.options);
    const value2 = Number(valueString);
    return resolveResult.ret(isNaN(value2) ? null : value2);
  }
};
var PromtResolver = class {
  constructor(options) {
    this.options = options;
  }
  run(deps) {
    return deps.prompt(this.options).then((x) => resolveResult.ret(x));
  }
};
var ConstResolver = class {
  constructor(value2) {
    this.value = value2;
  }
  run(deps) {
    return Promise.resolve(resolveResult.ret(this.value));
  }
};
var ChoiceResolver = class {
  constructor(options) {
    this.options = options;
  }
  run(deps) {
    return deps.suggest(this.options.options, this.options.prompt).then((result) => {
      return result ? (0, import_function2.pipe)(resolveResult.ret(result.value), addCommands(result.commands)) : resolveResult.ret(null);
    });
  }
};
var ObjectResolver = class {
  constructor(options) {
    this.options = options;
  }
  run(deps) {
    return this.options.reduce(
      async (prevP, curr) => (0, import_function2.pipe)(
        prevP,
        andThen(
          (prev) => (0, import_function2.pipe)(
            curr.resolver.run(deps),
            andThen((value2) => {
              if (!value2) {
                return resolveResult.ret(prev);
              }
              return resolveResult.ret({
                ...prev,
                [curr.key]: value2
              });
            })
          )
        )
      ),
      resolveResult.ret({})
    );
  }
};
var SetValue = class {
  constructor(key, option2) {
    this.key = key;
    this.option = option2;
  }
  run(deps) {
    return (0, import_function2.pipe)(
      this.option.run(deps),
      map2(
        (value2) => !value2 ? [] : [
          (metadata) => {
            metadata[this.key] = value2;
          }
        ]
      )
    );
  }
};
var AddToArray = class {
  constructor(key, option2) {
    this.key = key;
    this.option = option2;
  }
  async run(deps) {
    return (0, import_function2.pipe)(
      this.option.run(deps),
      map2((value2) => {
        if (!value2) {
          return [];
        }
        return [
          (metadata) => {
            const existing = metadata[this.key];
            metadata[this.key] = [
              ...Array.isArray(existing) ? existing : [],
              value2
            ];
          }
        ];
      })
    );
  }
};

// src/ConfigurationFactory.ts
var getResolver = (option2) => {
  switch (option2.$type) {
    case "number-input":
      return new NumberResolver(option2);
    case "string-input":
      return new PromtResolver(option2);
    case "choice-input": {
      const options = option2.options.map(({ commands, ...rest }) => ({
        ...rest,
        commands: createOperations(commands || [])
      }));
      return new ChoiceResolver({ ...option2, options });
    }
    case "object":
      return new ObjectResolver(
        option2.values.map(({ key, value: value2 }) => ({
          key,
          resolver: getResolver(value2)
        }))
      );
    case "constant":
      return new ConstResolver(option2.value);
  }
};
var createOperations = (options) => {
  return options.map((option2) => {
    switch (option2.$command) {
      case "add-array-element":
        return new AddToArray(option2.key, getResolver(option2.value));
      case "set-value":
        return new SetValue(option2.key, getResolver(option2.value));
    }
  });
};

// src/Forge.ts
var Forge = class {
  constructor(deps) {
    this.fileManager = deps.fileManager;
    this.commands = deps.commands;
    this.suggester = deps.suggester;
  }
  async getOperations() {
    const initial = [];
    const initialValue = { value: initial, commands: this.commands };
    const iter = (x) => {
      const { value: value2, commands } = x;
      if (commands.length === 0) {
        return Promise.resolve(x);
      }
      const [command2, ...rest] = commands;
      const r = (0, import_function3.pipe)(
        { value: value2, commands: rest },
        andThen((value3) => {
          return (0, import_function3.pipe)(
            command2.run(this.suggester),
            map2((result) => [...value3, ...result])
          );
        })
      );
      return r.then(iter);
    };
    return (await iter(initialValue)).value;
  }
  async run(file) {
    const operations = await this.getOperations();
    this.fileManager.processFrontMatter(file, (metadata) => {
      operations.forEach((x) => x(metadata));
    });
  }
};
var createForgeFromConfig = (deps) => {
  return new Forge({
    fileManager: deps.fileManager,
    suggester: deps.suggester,
    commands: createOperations(deps.forgeConfiguration.commands)
  });
};

// src/RootRunner.ts
var RootRunner = class {
  constructor(config, fileManager, modals) {
    this.config = config;
    this.fileManager = fileManager;
    this.modals = modals;
  }
  async run(file) {
    const forges = this.config.forges;
    if (!forges.length) {
      return;
    }
    const forgeConfiguration2 = forges.length === 1 ? forges[0] : await this.modals.suggest(
      this.config.forges.map((x) => ({ ...x, text: x.name }))
    );
    if (!forgeConfiguration2) {
      return;
    }
    const forge = createForgeFromConfig({
      fileManager: this.fileManager,
      forgeConfiguration: forgeConfiguration2,
      suggester: this.modals
    });
    await forge.run(file);
  }
};

// src/public-api.ts
var ForgeAPI = class {
  constructor(deps) {
    this.deps = deps;
  }
  async runOnFile(file) {
    const forge = createForgeFromConfig(this.deps);
    await forge.run(file);
  }
};
var FrontmatterSmithAPI = class {
  constructor(deps) {
    this.deps = deps;
  }
  findForgeByName(name) {
    const config = this.deps.getConfig();
    const forgeConfiguration2 = config.smithConfiguration.forges.find(
      (x) => x.name === name
    );
    return forgeConfiguration2 && new ForgeAPI({
      fileManager: this.deps.fileManager,
      suggester: this.deps.modals,
      forgeConfiguration: forgeConfiguration2
    });
  }
};

// main.ts
var FrontmatterSmithPlugin = class extends import_obsidian4.Plugin {
  async loadSettings() {
    const storedSettings = await this.loadData();
    this.settings = parseConfigurationOrDefault(storedSettings);
  }
  async onload() {
    await this.loadSettings();
    this.api = new FrontmatterSmithAPI({
      fileManager: this.app.fileManager,
      modals: new Modals(this.app, {
        FuzzySuggester,
        ObsidianPromptModal
      }),
      getConfig: () => this.settings
    });
    const handleSettingChange = (newValue) => {
      this.settings = newValue;
      settingsTab.setValue(newValue);
      this.saveData(newValue);
    };
    const settingsTab = new FrontmatterSmithSettingTab(
      this.app,
      this,
      handleSettingChange
    );
    settingsTab.setValue(this.settings);
    this.addSettingTab(settingsTab);
    this.addCommand({
      id: "forge-frontmatter",
      name: "Forge frontmatter",
      editorCallback: async (editor, view) => {
        const file = view.file;
        if (file) {
          const worker = new RootRunner(
            this.settings.smithConfiguration,
            this.app.fileManager,
            new Modals(this.app, {
              FuzzySuggester,
              ObsidianPromptModal
            })
          );
          await worker.run(file);
        }
      }
    });
  }
};
